<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Memory access of XiangShan H-Extension</title><meta name="description" content="This man is too lazy to introduce himself"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="香山处理器的 H 扩展里，内存部分的改动主要是增加了对两阶段翻译的支持。其中最主要的逻辑在于 L2 TLB 的实现。
Overview未实现 H 扩展之前
香山处理器只支持 SV39 的页表翻译，未实现 H 扩展之前，或者不在虚拟化模式下时。地址访问首先会询问 L1 TLB，取指和读写数据分别访问 ITLB 和 DTLB，均位于前端模块。在 TLB miss 之后，则需要查询 L2 TLB 甚至完整地走一遍地址翻译流程。
由于从 L1 TLB 到 L2 TLB 的距离比较长，需要在中间加拍，其中 Repeater 起延迟转发数据作用，Filter 负责整合相同地址的访问请求。
实现 H 扩展之后两阶段翻译(Stage-2 Translation) 增加了一层翻译。在香山的实现里，分为 S1 翻译和 S2 翻.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Xinrui Zheng's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Memory access of XiangShan H-Extension</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Overview"><span class="toc-text">Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E5%AE%9E%E7%8E%B0-H-%E6%89%A9%E5%B1%95%E4%B9%8B%E5%89%8D"><span class="toc-text">未实现 H 扩展之前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-H-%E6%89%A9%E5%B1%95%E4%B9%8B%E5%90%8E"><span class="toc-text">实现 H 扩展之后</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Implementation"><span class="toc-text">Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#L2-TLB"><span class="toc-text">L2 TLB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-Page-Cache-%E5%88%B0-Page-Table-Walker"><span class="toc-text">从 Page Cache 到 Page Table Walker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-Page-Table-Walker-%E5%88%B0-Page-Cache"><span class="toc-text">从 Page Table Walker 到 Page Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-text">访问物理内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">输出结果</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/RISC-V"><i class="tag post-item-tag">RISC-V</i></a><a href="/tags/Hardware"><i class="tag post-item-tag">Hardware</i></a><a href="/tags/XiangShan"><i class="tag post-item-tag">XiangShan</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Memory access of XiangShan H-Extension</h1><time class="has-text-grey" datetime="2023-09-18T12:11:40.026Z">2023-09-18</time><article class="mt-2 post-content"><p>香山处理器的 H 扩展里，内存部分的改动主要是增加了对两阶段翻译的支持。其中最主要的逻辑在于 L2 TLB 的实现。</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="未实现-H-扩展之前"><a href="#未实现-H-扩展之前" class="headerlink" title="未实现 H 扩展之前"></a>未实现 H 扩展之前</h2><p><img src="/source/images/XiangShanTLB.png" alt="TLB of XiangShan"></p>
<p>香山处理器只支持 SV39 的页表翻译，未实现 H 扩展之前，或者不在虚拟化模式下时。地址访问首先会询问 L1 TLB，取指和读写数据分别访问 ITLB 和 DTLB，均位于前端模块。在 TLB miss 之后，则需要查询 L2 TLB 甚至完整地走一遍地址翻译流程。</p>
<p>由于从 L1 TLB 到 L2 TLB 的距离比较长，需要在中间加拍，其中 Repeater 起延迟转发数据作用，Filter 负责整合相同地址的访问请求。</p>
<h2 id="实现-H-扩展之后"><a href="#实现-H-扩展之后" class="headerlink" title="实现 H 扩展之后"></a>实现 H 扩展之后</h2><p>两阶段翻译(Stage-2 Translation) 增加了一层翻译。在香山的实现里，分为 S1 翻译和 S2 翻译，其中 S1 翻译和原先的翻译流程兼容。换句话说，在没开启虚拟化的时候，S1 翻译会被正常使用，作为 PageWalker 的流程之一。</p>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>具体的实现从软件思维有些难以理解，因为代码没啥注释，组织也怪怪得。</p>
<h2 id="L2-TLB"><a href="#L2-TLB" class="headerlink" title="L2 TLB"></a>L2 TLB</h2><p>香山处理器的地址翻译可以说是以 Page Cache 作为中心的。Page Cache 包括了指令缓存和数据缓存，此外还记录了不同级的翻译映射关系，可以在一拍内完成翻译。外部的请求会发到 Page Cache 查询是否有缓存，内部的 Page Walker 和 Last-Level Page Walker 在每一级翻译的过程中都需要与 Page Cache 互动，将查询结果置于 Cache 中。</p>
<h3 id="从-Page-Cache-到-Page-Table-Walker"><a href="#从-Page-Cache-到-Page-Table-Walker" class="headerlink" title="从 Page Cache 到 Page Table Walker"></a>从 Page Cache 到 Page Table Walker</h3><p>在 Page Cache miss 之后，对 TLB entry 的访问需要经过完整的多级页表翻译，这项工作由 Page Table Walker (PTW) 和 Last-Level Page Table Walker (LLPTW) 完成，对于 H 扩展的两阶段翻译还有 Hypervisor Page Table Walker (HPTW) 的参与。</p>
<p>PTW</p>
<pre><code class="scala">  ptw.io.req.valid := cache.io.resp.valid &amp;&amp; !cache.io.resp.bits.hit &amp;&amp; !cache.io.resp.bits.toFsm.l2Hit &amp;&amp;
    !cache.io.resp.bits.bypassed &amp;&amp;
    !cache.io.resp.bits.isFirst &amp;&amp;
    !cache.io.resp.bits.isHptw
  ptw.io.req.bits.req_info := cache.io.resp.bits.req_info
  ptw.io.req.bits.l1Hit := cache.io.resp.bits.toFsm.l1Hit
  ptw.io.req.bits.ppn := cache.io.resp.bits.toFsm.ppn
  ptw.io.sfence := sfence_dup(7)
  ptw.io.csr := csr_dup(6)
  ptw.io.resp.ready := outReady(ptw.io.resp.bits.source, outArbFsmPort)
</code></pre>
<p>LLPTW</p>
<pre><code class="scala">  llptw.io.in.valid := cache.io.resp.valid &amp;&amp;
    !cache.io.resp.bits.hit &amp;&amp;
    cache.io.resp.bits.toFsm.l2Hit &amp;&amp;
    !cache.io.resp.bits.bypassed &amp;&amp;
    !cache.io.resp.bits.isHptw
  llptw.io.in.bits.req_info := cache.io.resp.bits.req_info
  llptw.io.in.bits.ppn := cache.io.resp.bits.toFsm.ppn
  llptw.io.sfence := sfence_dup(1)
  llptw.io.csr := csr_dup(1)
</code></pre>
<p>HPTW</p>
<pre><code class="scala">  hptw.io.req.valid := cache.io.resp.valid &amp;&amp; !cache.io.resp.bits.hit &amp;&amp; !cache.io.resp.bits.bypassed &amp; cache.io.resp.bits.isHptw
  hptw.io.req.bits.gvpn := cache.io.resp.bits.req_info.vpn
  hptw.io.req.bits.id := cache.io.resp.bits.toHptw.id
  hptw.io.req.bits.source := cache.io.resp.bits.req_info.source
  hptw.io.req.bits.l1Hit := cache.io.resp.bits.toHptw.l1Hit
  hptw.io.req.bits.l2Hit := cache.io.resp.bits.toHptw.l2Hit
  hptw.io.sfence := sfence_dup(8)
  hptw.io.csr := csr_dup(7) 
</code></pre>
<h3 id="从-Page-Table-Walker-到-Page-Cache"><a href="#从-Page-Table-Walker-到-Page-Cache" class="headerlink" title="从 Page Table Walker 到 Page Cache"></a>从 Page Table Walker 到 Page Cache</h3><pre><code class="scala">  cache.io.req.valid := arb2.io.out.valid
  cache.io.req.bits.req_info.vpn := arb2.io.out.bits.vpn
  cache.io.req.bits.req_info.s2xlate := arb2.io.out.bits.s2xlate
  cache.io.req.bits.req_info.source := arb2.io.out.bits.source
  cache.io.req.bits.isFirst := arb2.io.chosen =/= InArbMissQueuePort.U
  cache.io.req.bits.isHptw := arb2.io.chosen === InArbHPTWPort.U
  cache.io.req.bits.hptwId := hptw_id
  cache.io.req.bits.bypassed.map(_ := false.B)
  cache.io.sfence := sfence_dup(2)
  cache.io.csr := csr_dup(2)
  cache.io.sfence_dup.zip(sfence_dup.drop(2).take(4)).map(s =&gt; s._1 := s._2)
  cache.io.csr_dup.zip(csr_dup.drop(2).take(3)).map(c =&gt; c._1 := c._2)
  cache.io.resp.ready := Mux(cache.io.resp.bits.hit,
    outReady(cache.io.resp.bits.req_info.source, outArbCachePort),
    Mux(cache.io.resp.bits.toFsm.l2Hit &amp;&amp; !cache.io.resp.bits.bypassed, llptw.io.in.ready,
    Mux(cache.io.resp.bits.bypassed || cache.io.resp.bits.isFirst, mq_arb.io.in(0).ready, mq_arb.io.in(0).ready || ptw.io.req.ready)))
</code></pre>
<p>其中 <code>arb2</code> 整合了 PTW、LLPTW、HPTW 的请求信息。</p>
<pre><code class="scala">  arb1.io.in &lt;&gt; VecInit(io.tlb.map(_.req(0)))

  arb2.io.in(InArbPTWPort).valid := ptw.io.llptw.valid
  arb2.io.in(InArbPTWPort).bits.vpn := ptw.io.llptw.bits.req_info.vpn
  arb2.io.in(InArbPTWPort).bits.s2xlate := ptw.io.llptw.bits.req_info.s2xlate
  arb2.io.in(InArbPTWPort).bits.source := ptw.io.llptw.bits.req_info.source
  ptw.io.llptw.ready := arb2.io.in(InArbPTWPort).ready
  block_decoupled(missQueue.io.out, arb2.io.in(InArbMissQueuePort), !ptw.io.req.ready)

  arb2.io.in(InArbTlbPort).valid := arb1.io.out.valid
  arb2.io.in(InArbTlbPort).bits.vpn := arb1.io.out.bits.vpn
  arb2.io.in(InArbTlbPort).bits.s2xlate := arb1.io.out.bits.s2xlate
  arb2.io.in(InArbTlbPort).bits.source := arb1.io.chosen
  arb1.io.out.ready := arb2.io.in(InArbTlbPort).ready

  arb2.io.in(InArbHPTWPort).valid := hptw_req_arb.io.out.valid
  arb2.io.in(InArbHPTWPort).bits.vpn := hptw_req_arb.io.out.bits.gvpn
  arb2.io.in(InArbHPTWPort).bits.s2xlate := onlyStage2
  arb2.io.in(InArbHPTWPort).bits.source := hptw_req_arb.io.out.bits.source
</code></pre>
<h3 id="访问物理内存"><a href="#访问物理内存" class="headerlink" title="访问物理内存"></a>访问物理内存</h3><p>将获取 TLB entry 的请求发给内存控制器</p>
<pre><code class="scala">  val mem_arb = Module(new Arbiter(new L2TlbMemReqBundle(), 3))
  mem_arb.io.in(0) &lt;&gt; ptw.io.mem.req
  mem_arb.io.in(1) &lt;&gt; llptw_mem.req
  mem_arb.io.in(2) &lt;&gt; hptw.io.mem.req
  mem_arb.io.out.ready := mem.a.ready &amp;&amp; !flush
</code></pre>
<p>从内存读取 TLB entry。</p>
<pre><code class="scala">  // mem -&gt; llptw
  llptw_mem.resp.valid := mem_resp_done &amp;&amp; mem_resp_from_llptw
  llptw_mem.resp.bits.id := DataHoldBypass(mem.d.bits.source, mem.d.valid)
  // mem -&gt; ptw
  ptw.io.mem.req.ready := mem.a.ready
  ptw.io.mem.resp.valid := mem_resp_done &amp;&amp; mem_resp_from_ptw
  ptw.io.mem.resp.bits := resp_pte.apply(l2tlbParams.llptwsize)
  // mem -&gt; hptw
  hptw.io.mem.req.ready := mem.a.ready
  hptw.io.mem.resp.valid := mem_resp_done &amp;&amp; mem_resp_from_hptw
  hptw.io.mem.resp.bits := resp_pte.apply(l2tlbParams.llptwsize + 1)
</code></pre>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>将 HPTW 的东西整合到 PTW 和 LLPTW 中：</p>
<pre><code class="scala">  ptw.io.hptw.resp.valid := hptw_resp_arb.io.out.valid &amp;&amp; hptw_resp_arb.io.out.bits.id === FsmReqID.U
  ptw.io.hptw.resp.bits.h_resp := hptw_resp_arb.io.out.bits.resp
  llptw.io.hptw.resp.valid := hptw_resp_arb.io.out.valid &amp;&amp; hptw_resp_arb.io.out.bits.id =/= FsmReqID.U
  llptw.io.hptw.resp.bits.id := hptw_resp_arb.io.out.bits.id
  llptw.io.hptw.resp.bits.h_resp := hptw_resp_arb.io.out.bits.resp
  hptw_resp_arb.io.out.ready := true.B

  ptw.io.hptw.resp.valid := hptw_resp_arb.io.out.valid &amp;&amp; hptw_resp_arb.io.out.bits.id === FsmReqID.U
  ptw.io.hptw.resp.bits.h_resp := hptw_resp_arb.io.out.bits.resp
  llptw.io.hptw.resp.valid := hptw_resp_arb.io.out.valid &amp;&amp; hptw_resp_arb.io.out.bits.id =/= FsmReqID.U
  llptw.io.hptw.resp.bits.id := hptw_resp_arb.io.out.bits.id
  llptw.io.hptw.resp.bits.h_resp := hptw_resp_arb.io.out.bits.resp
  hptw_resp_arb.io.out.ready := true.B
</code></pre>
<pre><code class="scala">  for (i &lt;- 0 until PtwWidth) &#123;
    mergeArb(i).in(outArbCachePort).valid := cache.io.resp.valid &amp;&amp; cache.io.resp.bits.hit &amp;&amp; cache.io.resp.bits.req_info.source===i.U
    mergeArb(i).in(outArbCachePort).bits.s2xlate := cache.io.resp.bits.req_info.s2xlate
    mergeArb(i).in(outArbCachePort).bits.s1 := cache.io.resp.bits.toTlb
    mergeArb(i).in(outArbCachePort).bits.s2 := cache.io.resp.bits.toHptw.resp
    mergeArb(i).in(outArbFsmPort).valid := ptw.io.resp.valid &amp;&amp; ptw.io.resp.bits.source===i.U
    mergeArb(i).in(outArbFsmPort).bits.s2xlate := ptw.io.resp.bits.s2xlate
    mergeArb(i).in(outArbFsmPort).bits.s1 := ptw.io.resp.bits.resp
    mergeArb(i).in(outArbFsmPort).bits.s2 := ptw.io.resp.bits.h_resp
    mergeArb(i).in(outArbMqPort).valid := llptw_out.valid &amp;&amp; llptw_out.bits.req_info.source===i.U
    mergeArb(i).in(outArbMqPort).bits.s2xlate := llptw_out.bits.req_info.s2xlate
    mergeArb(i).in(outArbMqPort).bits.s1 := contiguous_pte_to_merge_ptwResp(resp_pte_sector(llptw_out.bits.id).asUInt, llptw_out.bits.req_info.vpn, llptw_out.bits.af, true, s2xlate = llptw_out.bits.req_info.s2xlate)
    mergeArb(i).in(outArbMqPort).bits.s2 := llptw_out.bits.h_resp
    mergeArb(i).out.ready := outArb(i).in(0).ready
  &#125;

  for (i &lt;- 0 until PtwWidth) &#123;
    outArb(i).in(0).valid := mergeArb(i).out.valid
    outArb(i).in(0).bits.s2xlate := mergeArb(i).out.bits.s2xlate
    outArb(i).in(0).bits.s1 := merge_ptwResp_to_sector_ptwResp(mergeArb(i).out.bits.s1)
    outArb(i).in(0).bits.s2 := mergeArb(i).out.bits.s2
  &#125;

  // io.tlb.map(_.resp) &lt;&gt; outArb.map(_.out)
  io.tlb.map(_.resp).zip(outArb.map(_.out)).map&#123;
    case (resp, out) =&gt; resp &lt;&gt; out
  &#125;
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/09/07/NEMU-H-Ext/" title="NEMU-H-Ext"><span class="has-text-weight-semibold">Next: NEMU-H-Ext</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="BL-GS/BLGS.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/BL-GS"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/people/blgs"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Xinrui Zheng 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>