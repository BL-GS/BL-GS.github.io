<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://bl-gs.github.io/atom.xml" rel="self"/>
  
  <link href="http://bl-gs.github.io/"/>
  <updated>2023-09-19T01:15:42.546Z</updated>
  <id>http://bl-gs.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Memory access of XiangShan H-Extension</title>
    <link href="http://bl-gs.github.io/2023/09/18/XiangShanHExtMemory/"/>
    <id>http://bl-gs.github.io/2023/09/18/XiangShanHExtMemory/</id>
    <published>2023-09-18T12:11:40.026Z</published>
    <updated>2023-09-19T01:15:42.546Z</updated>
    
    <content type="html"><![CDATA[<p>香山处理器的 H 扩展里，内存部分的改动主要是增加了对两阶段翻译的支持。其中最主要的逻辑在于 L2 TLB 的实现。</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="未实现-H-扩展之前"><a href="#未实现-H-扩展之前" class="headerlink" title="未实现 H 扩展之前"></a>未实现 H 扩展之前</h2><p><img src="/source/images/XiangShanTLB.png" alt="TLB of XiangShan"></p><p>香山处理器只支持 SV39 的页表翻译，未实现 H 扩展之前，或者不在虚拟化模式下时。地址访问首先会询问 L1 TLB，取指和读写数据分别访问 ITLB 和 DTLB，均位于前端模块。在 TLB miss 之后，则需要查询 L2 TLB 甚至完整地走一遍地址翻译流程。</p><p>由于从 L1 TLB 到 L2 TLB 的距离比较长，需要在中间加拍，其中 Repeater 起延迟转发数据作用，Filter 负责整合相同地址的访问请求。</p><h2 id="实现-H-扩展之后"><a href="#实现-H-扩展之后" class="headerlink" title="实现 H 扩展之后"></a>实现 H 扩展之后</h2><p>两阶段翻译(Stage-2 Translation) 增加了一层翻译。在香山的实现里，分为 S1 翻译和 S2 翻译，其中 S1 翻译和原先的翻译流程兼容。换句话说，在没开启虚拟化的时候，S1 翻译会被正常使用，作为 PageWalker 的流程之一。</p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>具体的实现从软件思维有些难以理解，因为代码没啥注释，组织也怪怪得。</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ul><li>HPTW: 说是完成第二阶段翻译有点夸张，更多是作为第一阶段翻译到第二阶段的中间转换接口</li><li>PTW：通过状态机的方式完成 SV39 页表翻译，只能同时处理一个请求，并且最多只访问前两级页表。在 H 扩展下还添加了第二阶段翻译的支持。</li><li>LLPTW：专门处理 SV39 页表翻译的最后一级翻译，不合并重复的请求，而是记录下来，共享访存结果，避免重复访问内存。在 H 扩展下还添加了第二阶段翻译的支持。</li><li>PtwCache：缓存地址翻译映射，包括一二三级的地址映射；每级 walker 都需要返回结果给它供缓存。在 H 扩展下还标识了 h、g、v 标志位。</li></ul><h2 id="L2-TLB"><a href="#L2-TLB" class="headerlink" title="L2 TLB"></a>L2 TLB</h2><p>香山处理器的地址翻译可以说是以 Page Cache 作为中心的。Page Cache 包括了指令缓存和数据缓存，此外还记录了不同级的翻译映射关系，可以在一拍内完成翻译。外部的请求会发到 Page Cache 查询是否有缓存，内部的 Page Walker 和 Last-Level Page Walker 在每一级翻译的过程中都需要与 Page Cache 互动，将查询结果置于 Cache 中。</p><h3 id="从-Page-Cache-到-Page-Table-Walker"><a href="#从-Page-Cache-到-Page-Table-Walker" class="headerlink" title="从 Page Cache 到 Page Table Walker"></a>从 Page Cache 到 Page Table Walker</h3><p>在 Page Cache miss 之后，对 TLB entry 的访问需要经过完整的多级页表翻译，这项工作由 Page Table Walker (PTW) 和 Last-Level Page Table Walker (LLPTW) 完成，对于 H 扩展的两阶段翻译还有 Hypervisor Page Table Walker (HPTW) 的参与。</p><p>PTW</p><pre><code class="scala">  ptw.io.req.valid := cache.io.resp.valid &amp;&amp; !cache.io.resp.bits.hit &amp;&amp; !cache.io.resp.bits.toFsm.l2Hit &amp;&amp;    !cache.io.resp.bits.bypassed &amp;&amp;    !cache.io.resp.bits.isFirst &amp;&amp;    !cache.io.resp.bits.isHptw  ptw.io.req.bits.req_info := cache.io.resp.bits.req_info  ptw.io.req.bits.l1Hit := cache.io.resp.bits.toFsm.l1Hit  ptw.io.req.bits.ppn := cache.io.resp.bits.toFsm.ppn  ptw.io.sfence := sfence_dup(7)  ptw.io.csr := csr_dup(6)  ptw.io.resp.ready := outReady(ptw.io.resp.bits.source, outArbFsmPort)</code></pre><p>LLPTW</p><pre><code class="scala">  llptw.io.in.valid := cache.io.resp.valid &amp;&amp;    !cache.io.resp.bits.hit &amp;&amp;    cache.io.resp.bits.toFsm.l2Hit &amp;&amp;    !cache.io.resp.bits.bypassed &amp;&amp;    !cache.io.resp.bits.isHptw  llptw.io.in.bits.req_info := cache.io.resp.bits.req_info  llptw.io.in.bits.ppn := cache.io.resp.bits.toFsm.ppn  llptw.io.sfence := sfence_dup(1)  llptw.io.csr := csr_dup(1)</code></pre><p>HPTW</p><pre><code class="scala">  hptw.io.req.valid := cache.io.resp.valid &amp;&amp; !cache.io.resp.bits.hit &amp;&amp; !cache.io.resp.bits.bypassed &amp; cache.io.resp.bits.isHptw  hptw.io.req.bits.gvpn := cache.io.resp.bits.req_info.vpn  hptw.io.req.bits.id := cache.io.resp.bits.toHptw.id  hptw.io.req.bits.source := cache.io.resp.bits.req_info.source  hptw.io.req.bits.l1Hit := cache.io.resp.bits.toHptw.l1Hit  hptw.io.req.bits.l2Hit := cache.io.resp.bits.toHptw.l2Hit  hptw.io.sfence := sfence_dup(8)  hptw.io.csr := csr_dup(7) </code></pre><h3 id="从-Page-Table-Walker-到-Page-Cache"><a href="#从-Page-Table-Walker-到-Page-Cache" class="headerlink" title="从 Page Table Walker 到 Page Cache"></a>从 Page Table Walker 到 Page Cache</h3><p>在一级翻译后，需要将对应的请求信息再次发送到 Cache 中查看是否有匹配的 entry，同时还能将 entry 记录起来。</p><pre><code class="scala">  cache.io.req.valid := arb2.io.out.valid  cache.io.req.bits.req_info.vpn := arb2.io.out.bits.vpn  cache.io.req.bits.req_info.s2xlate := arb2.io.out.bits.s2xlate  cache.io.req.bits.req_info.source := arb2.io.out.bits.source  cache.io.req.bits.isFirst := arb2.io.chosen =/= InArbMissQueuePort.U  cache.io.req.bits.isHptw := arb2.io.chosen === InArbHPTWPort.U  cache.io.req.bits.hptwId := hptw_id  cache.io.req.bits.bypassed.map(_ := false.B)  cache.io.sfence := sfence_dup(2)  cache.io.csr := csr_dup(2)  cache.io.sfence_dup.zip(sfence_dup.drop(2).take(4)).map(s =&gt; s._1 := s._2)  cache.io.csr_dup.zip(csr_dup.drop(2).take(3)).map(c =&gt; c._1 := c._2)  cache.io.resp.ready := Mux(cache.io.resp.bits.hit,    outReady(cache.io.resp.bits.req_info.source, outArbCachePort),    Mux(cache.io.resp.bits.toFsm.l2Hit &amp;&amp; !cache.io.resp.bits.bypassed, llptw.io.in.ready,    Mux(cache.io.resp.bits.bypassed || cache.io.resp.bits.isFirst, mq_arb.io.in(0).ready, mq_arb.io.in(0).ready || ptw.io.req.ready)))</code></pre><p>其中 <code>arb2</code> 整合了 PTW、LLPTW、HPTW 的请求信息。</p><pre><code class="scala">  arb1.io.in &lt;&gt; VecInit(io.tlb.map(_.req(0)))  arb2.io.in(InArbPTWPort).valid := ptw.io.llptw.valid  arb2.io.in(InArbPTWPort).bits.vpn := ptw.io.llptw.bits.req_info.vpn  arb2.io.in(InArbPTWPort).bits.s2xlate := ptw.io.llptw.bits.req_info.s2xlate  arb2.io.in(InArbPTWPort).bits.source := ptw.io.llptw.bits.req_info.source  ptw.io.llptw.ready := arb2.io.in(InArbPTWPort).ready  block_decoupled(missQueue.io.out, arb2.io.in(InArbMissQueuePort), !ptw.io.req.ready)  arb2.io.in(InArbTlbPort).valid := arb1.io.out.valid  arb2.io.in(InArbTlbPort).bits.vpn := arb1.io.out.bits.vpn  arb2.io.in(InArbTlbPort).bits.s2xlate := arb1.io.out.bits.s2xlate  arb2.io.in(InArbTlbPort).bits.source := arb1.io.chosen  arb1.io.out.ready := arb2.io.in(InArbTlbPort).ready  arb2.io.in(InArbHPTWPort).valid := hptw_req_arb.io.out.valid  arb2.io.in(InArbHPTWPort).bits.vpn := hptw_req_arb.io.out.bits.gvpn  arb2.io.in(InArbHPTWPort).bits.s2xlate := onlyStage2  arb2.io.in(InArbHPTWPort).bits.source := hptw_req_arb.io.out.bits.source</code></pre><h3 id="第二阶段翻译"><a href="#第二阶段翻译" class="headerlink" title="第二阶段翻译"></a>第二阶段翻译</h3><p>也就是将 PTW 和 LLPTW 的翻译结果交给 HPTW 做进一步翻译</p><pre><code class="scala"> val InHptwArbPTWPort = 0  val InHptwArbLLPTWPort = 1  hptw_req_arb.io.in(InHptwArbPTWPort).valid := ptw.io.hptw.req.valid  hptw_req_arb.io.in(InHptwArbPTWPort).bits.gvpn := ptw.io.hptw.req.bits.gvpn  hptw_req_arb.io.in(InHptwArbPTWPort).bits.id := ptw.io.hptw.req.bits.id  hptw_req_arb.io.in(InHptwArbPTWPort).bits.source := ptw.io.hptw.req.bits.source  ptw.io.hptw.req.ready := hptw_req_arb.io.in(InHptwArbPTWPort).ready  hptw_req_arb.io.in(InHptwArbLLPTWPort).valid := llptw.io.hptw.req.valid  hptw_req_arb.io.in(InHptwArbLLPTWPort).bits.gvpn := llptw.io.hptw.req.bits.gvpn  hptw_req_arb.io.in(InHptwArbLLPTWPort).bits.id := llptw.io.hptw.req.bits.id  hptw_req_arb.io.in(InHptwArbLLPTWPort).bits.source := llptw.io.hptw.req.bits.source  llptw.io.hptw.req.ready := hptw_req_arb.io.in(InHptwArbLLPTWPort).ready</code></pre><h3 id="访问物理内存"><a href="#访问物理内存" class="headerlink" title="访问物理内存"></a>访问物理内存</h3><p>将获取 TLB entry 的请求发给内存控制器</p><pre><code class="scala">  val mem_arb = Module(new Arbiter(new L2TlbMemReqBundle(), 3))  mem_arb.io.in(0) &lt;&gt; ptw.io.mem.req  mem_arb.io.in(1) &lt;&gt; llptw_mem.req  mem_arb.io.in(2) &lt;&gt; hptw.io.mem.req  mem_arb.io.out.ready := mem.a.ready &amp;&amp; !flush</code></pre><p>将从内存读取 TLB entry 发送到 PTW 中做进一步处理。</p><pre><code class="scala">  // mem -&gt; llptw  llptw_mem.resp.valid := mem_resp_done &amp;&amp; mem_resp_from_llptw  llptw_mem.resp.bits.id := DataHoldBypass(mem.d.bits.source, mem.d.valid)  // mem -&gt; ptw  ptw.io.mem.req.ready := mem.a.ready  ptw.io.mem.resp.valid := mem_resp_done &amp;&amp; mem_resp_from_ptw  ptw.io.mem.resp.bits := resp_pte.apply(l2tlbParams.llptwsize)  // mem -&gt; hptw  hptw.io.mem.req.ready := mem.a.ready  hptw.io.mem.resp.valid := mem_resp_done &amp;&amp; mem_resp_from_hptw  hptw.io.mem.resp.bits := resp_pte.apply(l2tlbParams.llptwsize + 1)</code></pre><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>将 HPTW 的东西整合到 PTW 和 LLPTW 中：</p><pre><code class="scala">  ptw.io.hptw.resp.valid := hptw_resp_arb.io.out.valid &amp;&amp; hptw_resp_arb.io.out.bits.id === FsmReqID.U  ptw.io.hptw.resp.bits.h_resp := hptw_resp_arb.io.out.bits.resp  llptw.io.hptw.resp.valid := hptw_resp_arb.io.out.valid &amp;&amp; hptw_resp_arb.io.out.bits.id =/= FsmReqID.U  llptw.io.hptw.resp.bits.id := hptw_resp_arb.io.out.bits.id  llptw.io.hptw.resp.bits.h_resp := hptw_resp_arb.io.out.bits.resp  hptw_resp_arb.io.out.ready := true.B  ptw.io.hptw.resp.valid := hptw_resp_arb.io.out.valid &amp;&amp; hptw_resp_arb.io.out.bits.id === FsmReqID.U  ptw.io.hptw.resp.bits.h_resp := hptw_resp_arb.io.out.bits.resp  llptw.io.hptw.resp.valid := hptw_resp_arb.io.out.valid &amp;&amp; hptw_resp_arb.io.out.bits.id =/= FsmReqID.U  llptw.io.hptw.resp.bits.id := hptw_resp_arb.io.out.bits.id  llptw.io.hptw.resp.bits.h_resp := hptw_resp_arb.io.out.bits.resp  hptw_resp_arb.io.out.ready := true.B</code></pre><p>然后经由 <code>mergeArb</code> 和 <code>outArb</code> 整合成输出</p><pre><code class="scala">  for (i &lt;- 0 until PtwWidth) &#123;    mergeArb(i).in(outArbCachePort).valid := cache.io.resp.valid &amp;&amp; cache.io.resp.bits.hit &amp;&amp; cache.io.resp.bits.req_info.source===i.U    mergeArb(i).in(outArbCachePort).bits.s2xlate := cache.io.resp.bits.req_info.s2xlate    mergeArb(i).in(outArbCachePort).bits.s1 := cache.io.resp.bits.toTlb    mergeArb(i).in(outArbCachePort).bits.s2 := cache.io.resp.bits.toHptw.resp    mergeArb(i).in(outArbFsmPort).valid := ptw.io.resp.valid &amp;&amp; ptw.io.resp.bits.source===i.U    mergeArb(i).in(outArbFsmPort).bits.s2xlate := ptw.io.resp.bits.s2xlate    mergeArb(i).in(outArbFsmPort).bits.s1 := ptw.io.resp.bits.resp    mergeArb(i).in(outArbFsmPort).bits.s2 := ptw.io.resp.bits.h_resp    mergeArb(i).in(outArbMqPort).valid := llptw_out.valid &amp;&amp; llptw_out.bits.req_info.source===i.U    mergeArb(i).in(outArbMqPort).bits.s2xlate := llptw_out.bits.req_info.s2xlate    mergeArb(i).in(outArbMqPort).bits.s1 := contiguous_pte_to_merge_ptwResp(resp_pte_sector(llptw_out.bits.id).asUInt, llptw_out.bits.req_info.vpn, llptw_out.bits.af, true, s2xlate = llptw_out.bits.req_info.s2xlate)    mergeArb(i).in(outArbMqPort).bits.s2 := llptw_out.bits.h_resp    mergeArb(i).out.ready := outArb(i).in(0).ready  &#125;  for (i &lt;- 0 until PtwWidth) &#123;    outArb(i).in(0).valid := mergeArb(i).out.valid    outArb(i).in(0).bits.s2xlate := mergeArb(i).out.bits.s2xlate    outArb(i).in(0).bits.s1 := merge_ptwResp_to_sector_ptwResp(mergeArb(i).out.bits.s1)    outArb(i).in(0).bits.s2 := mergeArb(i).out.bits.s2  &#125;  // io.tlb.map(_.resp) &lt;&gt; outArb.map(_.out)  io.tlb.map(_.resp).zip(outArb.map(_.out)).map&#123;    case (resp, out) =&gt; resp &lt;&gt; out  &#125;</code></pre><h2 id="具体的翻译流程"><a href="#具体的翻译流程" class="headerlink" title="具体的翻译流程"></a>具体的翻译流程</h2><p>简要的说，在二阶段翻译时，虚拟地址首先传入 PTW 中翻译成 gpaddr，经由 PTW 中 hptw_req 接口传到 HPTW，HPTW 只负责第二阶段翻译。</p><h3 id="第一阶段翻译"><a href="#第一阶段翻译" class="headerlink" title="第一阶段翻译"></a>第一阶段翻译</h3><p>由于硬件模块会更加抽象一些，加上代码没有注释，刚开始属实是毫无思路。。。甚至分不清 HPTW 到底负责哪一个阶段的翻译。</p><p>来到 <code>PTW</code> 类内部：<br>寄存器通过判断得到 <code>vsatp</code> 的值：</p><pre><code class="scala">val satp = Mux(enableS2xlate, io.csr.vsatp, io.csr.satp)</code></pre><p>在 2 级翻译时需要访问内存：</p><pre><code class="scala">val mem = io.mem...val pte = mem.resp.bits.asTypeOf(new PteBundle().cloneType)</code></pre><p>然后拼接出对应的地址：</p><pre><code class="scala">val l1addr = MakeAddr(satp.ppn, getVpnn(vpn, 2))val l2addr = MakeAddr(Mux(l1Hit, ppn, pte.ppn), getVpnn(vpn, 1))</code></pre><p>根据翻译 level 选择地址：</p><pre><code class="scala">val mem_addr = Mux(af_level === 0.U, l1addr, l2addr)</code></pre><p>得到客户物理地址 GPA：</p><pre><code class="scala">val gpaddr = Mux(onlyS2xlate, Cat(vpn, 0.U(offLen.W)), mem_addr)</code></pre><p>将结果发送给 HPTW：</p><pre><code class="scala">io.hptw.req.valid := !s_hptw_req || !s_last_hptw_reqio.hptw.req.bits.id := FsmReqID.U(bMemID.W)io.hptw.req.bits.gvpn := get_pn(gpaddr)io.hptw.req.bits.source := source</code></pre><p>在 <code>L2TLB</code> 类中，这些结果会被传递到 PageCache 里：</p><pre><code class="scala">val InHptwArbPTWPort = 0val InHptwArbLLPTWPort = 1hptw_req_arb.io.in(InHptwArbPTWPort).valid := ptw.io.hptw.req.validhptw_req_arb.io.in(InHptwArbPTWPort).bits.gvpn := ptw.io.hptw.req.bits.gvpnhptw_req_arb.io.in(InHptwArbPTWPort).bits.id := ptw.io.hptw.req.bits.idhptw_req_arb.io.in(InHptwArbPTWPort).bits.source := ptw.io.hptw.req.bits.sourceptw.io.hptw.req.ready := hptw_req_arb.io.in(InHptwArbPTWPort).ready...cache.io.req.valid := arb2.io.out.validcache.io.req.bits.req_info.vpn := arb2.io.out.bits.vpncache.io.req.bits.req_info.s2xlate := arb2.io.out.bits.s2xlatecache.io.req.bits.req_info.source := arb2.io.out.bits.sourcecache.io.req.bits.isFirst := arb2.io.chosen =/= InArbMissQueuePort.Ucache.io.req.bits.isHptw := arb2.io.chosen === InArbHPTWPort.U</code></pre><p>之后<code>PTW</code> 会再次从 PageCache 或者 HPTW 接收到二阶段地址翻译的请求，进入第二阶段翻译</p><pre><code class="scala">val HptwRespArbCachePort = 0val HptwRespArbHptw = 1hptw_resp_arb.io.in(HptwRespArbCachePort).valid := cache.io.resp.valid &amp;&amp; cache.io.resp.bits.hit &amp;&amp; cache.io.resp.bits.isHptwhptw_resp_arb.io.in(HptwRespArbCachePort).bits.id := cache.io.resp.bits.toHptw.idhptw_resp_arb.io.in(HptwRespArbCachePort).bits.resp := cache.io.resp.bits.toHptw.resphptw_resp_arb.io.in(HptwRespArbHptw).valid := hptw.io.resp.validhptw_resp_arb.io.in(HptwRespArbHptw).bits.id := hptw.io.resp.bits.idhptw_resp_arb.io.in(HptwRespArbHptw).bits.resp := hptw.io.resp.bits.resp...ptw.io.hptw.resp.valid := hptw_resp_arb.io.out.valid &amp;&amp; hptw_resp_arb.io.out.bits.id === FsmReqID.Uptw.io.hptw.resp.bits.h_resp := hptw_resp_arb.io.out.bits.resp</code></pre><h3 id="第二阶段翻译-1"><a href="#第二阶段翻译-1" class="headerlink" title="第二阶段翻译"></a>第二阶段翻译</h3><p>在 PTW 里处理得到宿主物理地址 HPA：</p><pre><code class="scala">val hptw_resp = io.hptw.resp.bits.h_respval hpaddr = Cat(hptw_resp.entry.ppn, 0.U(offLen.W))</code></pre><p>向内存提出读取请求，从内存取出 pte：</p><pre><code class="scala">mem.req.valid := s_mem_req === false.B &amp;&amp; !mem.mask &amp;&amp; !accessFault &amp;&amp; s_pmp_checkmem.req.bits.addr := Mux(s2xlate, hpaddr, mem_addr)mem.req.bits.id := FsmReqID.U(bMemID.W)</code></pre><p>同样的从内存取出 pte：</p><pre><code class="scala">val pte = mem.resp.bits.asTypeOf(new PteBundle().cloneType)</code></pre><p>然后将其输出：</p><pre><code class="scala">io.resp.valid := idle === false.B &amp;&amp; mem_addr_update &amp;&amp; !last_s2xlate &amp;&amp; ((w_mem_resp &amp;&amp; find_pte) || (s_pmp_check &amp;&amp; accessFault) || onlyS2xlate)io.resp.bits.source := sourceio.resp.bits.resp.apply(pageFault &amp;&amp; !accessFault &amp;&amp; !ppn_af, accessFault || ppn_af, Mux(accessFault, af_level,level), pte, vpn, satp.asid, hgatp.asid, vpn(sectortlbwidth - 1, 0), not_super = false)io.resp.bits.h_resp := io.hptw.resp.bits.h_respio.resp.bits.s2xlate := s2xlate</code></pre><p>之后会将其发送给 PageCache。LLPTW 的过程基本一致，不过作为最后一级翻译，其结果还可以返回到顶层模块。</p><p>这里可能有的疑惑是第二阶段的翻译需要经历一个完整的三级页表翻译，但是这里好像直接一下子就从 GPA 得到了 HPA。其实从上面代码可以看到其结果来自 PageCache 或者 HPTW：PageCache 的自不必说，有一些判定位决定翻译是否 bypass 是否 valid；但是 HPTW 这里再介绍下它的流程：</p><p>在得到 GPA 后：</p><p>最后得到输出的 HPA，从而去访问内存。在第一级翻译可以直接使用 hgatp 寄存器的值作为物理页号 PPN。</p><pre><code class="scala">val pg_base = MakeGAddr(hgatp.ppn, getGVpnn(vpn, 2.U))val p_pte = MakeAddr(ppn, getVpnn(vpn, 2.U - level))val mem_addr = Mux(level === 0.U, pg_base, p_pte)...io.mem.req.valid := !s_mem_req &amp;&amp; !io.mem.mask &amp;&amp; !accessFault &amp;&amp; s_pmp_checkio.mem.req.bits.addr := mem_addrio.mem.req.bits.id := HptwReqId.U(bMemID.W)</code></pre><p>在内存返回结果后，提取 PPN，以支持下一级翻译</p><pre><code class="scala">when(io.mem.resp.fire() &amp;&amp; !w_mem_resp)&#123;    ppn := pte.ppn    w_mem_resp := true.B    mem_addr_update := true.B&#125;</code></pre><p>当找到叶子页表时，结束翻译，使能输出</p><pre><code class="scala">val find_pte = pte.isLeaf() || ppn_af || pageFaultval resp_valid = !idle &amp;&amp; mem_addr_update &amp;&amp; ((w_mem_resp &amp;&amp; find_pte) || (s_pmp_check &amp;&amp; accessFault))...val resp = Wire(new HptwResp())resp.apply(pageFault &amp;&amp; !accessFault &amp;&amp; !ppn_af, accessFault || ppn_af, level, pte, vpn, hgatp.asid)io.resp.valid := resp_validio.resp.bits.id := idio.resp.bits.resp := respio.resp.bits.source := source...when(mem_addr_update)&#123;    when(!(find_pte || accessFault))&#123;        level := levelNext        s_mem_req := false.B        mem_addr_update := false.B    &#125;.elsewhen(resp_valid)&#123;        when(io.resp.fire())&#123;            idle := true.B            mem_addr_update := false.B            accessFault := false.B        &#125;        finish := true.B    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;香山处理器的 H 扩展里，内存部分的改动主要是增加了对两阶段翻译的支持。其中最主要的逻辑在于 L2 TLB 的实现。&lt;/p&gt;
&lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;</summary>
      
    
    
    
    <category term="Hardware" scheme="http://bl-gs.github.io/categories/Hardware/"/>
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/categories/Hardware/RISC-V/"/>
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/tags/RISC-V/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/tags/Hardware/"/>
    
    <category term="XiangShan" scheme="http://bl-gs.github.io/tags/XiangShan/"/>
    
  </entry>
  
  <entry>
    <title>NEMU-H-Ext</title>
    <link href="http://bl-gs.github.io/2023/09/07/NEMU-H-Ext/"/>
    <id>http://bl-gs.github.io/2023/09/07/NEMU-H-Ext/</id>
    <published>2023-09-07T02:13:08.470Z</published>
    <updated>2023-09-14T11:51:19.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="H-Extension-Difftest"><a href="#H-Extension-Difftest" class="headerlink" title="H Extension Difftest"></a>H Extension Difftest</h1><p>通过 Spike 进行 difftest 功能验证</p><pre><code class="shell">git clone https://github.com/OpenXiangShan/riscv-isa-sim.gitcd riscv-isa-simgit checkout h-extcd difftest &amp;&amp; make -j</code></pre><p>即可获得用于 NEMU Difftest 的 Spike 动态链接库</p><h1 id="KVM-NEMU-模拟"><a href="#KVM-NEMU-模拟" class="headerlink" title="KVM NEMU 模拟"></a>KVM NEMU 模拟</h1><ol><li><p>按照教程 <a href="https://github.com/kvm-riscv/howto/wiki/KVM-RISCV64-on-QEMU">KVM RISCV64 on QEMU · kvm-riscv&#x2F;howto Wiki (github.com)</a> 构建一个 QEMU 上的 KVM Linux 工作负载。QEMU 输出可以作为 Debug 参照</p></li><li><p>打开 Linux menuconfig，配置</p><pre><code>General setup -&gt;    Initramfs source file(s) 填入 busybox 的安装目录地址Kernel features -&gt;       SBI v0.1 support Device Drivers -&gt;      Character devices         Serial driver -&gt;             Early console using RISC-V SBI         RISC-V SBI console support</code></pre></li><li><p>将 <a href="https://github.com/OpenXiangShan/riscv-pk/tree/noop/dts">riscv-pk&#x2F;dts at noop · OpenXiangShan&#x2F;riscv-pk (github.com)</a> 中的 dts 下下来，主要是 system.dts 和 noop.dtsi 文件。配置 platform.dtsi 软连接到 noop.dtsi。</p></li><li><p>修改 system.dtsi 中 <code>L6: cpu</code> 的 <code>riscv,isa</code> 为 <code>rv64imafdch</code> 。主要确保 h 标志位。</p></li><li><p>修改 noop.dtsi 中的 bootargs 为：<code>console=hvc0 earlycon=sbi</code></p></li><li><p>整合设备树 <code>dtc -O dtb -o xiangshan.dtb system.dtb</code>。注意 system.dts 和 platform.dtsi 在同一目录下</p></li><li><p>编译 opensbi：</p><pre><code class="shell">make PLATFORM=generic CROSS_COMPILE=riscv64-unknown-linux-gnu- FW_FDT_PATH=&lt;dtb path&gt;/xiangshan.dtb FW_PAYLOAD_PATH=&lt;workspace path&gt;/build-riscv64/arch/riscv/boot/Image  -j</code></pre></li><li><p>得到的 <code>opensbi/build/platform/generic/fireware/fw_payload.bin</code> 即可作为可执行文件给 NEMU 执行</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;H-Extension-Difftest&quot;&gt;&lt;a href=&quot;#H-Extension-Difftest&quot; class=&quot;headerlink&quot; title=&quot;H Extension Difftest&quot;&gt;&lt;/a&gt;H Extension Difftest&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/categories/RISC-V/"/>
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/tags/RISC-V/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/tags/Hardware/"/>
    
    <category term="Privileged mode" scheme="http://bl-gs.github.io/tags/Privileged-mode/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V Memory System</title>
    <link href="http://bl-gs.github.io/2023/09/01/RISCV-Memory%20System/"/>
    <id>http://bl-gs.github.io/2023/09/01/RISCV-Memory%20System/</id>
    <published>2023-09-01T07:28:03.622Z</published>
    <updated>2023-09-01T07:31:50.910Z</updated>
    
    
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/categories/RISC-V/"/>
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/tags/RISC-V/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/tags/Hardware/"/>
    
    <category term="Privileged mode" scheme="http://bl-gs.github.io/tags/Privileged-mode/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V Machine-Level ISA</title>
    <link href="http://bl-gs.github.io/2023/09/01/RISCV-Supervisor-Level%20ISA/"/>
    <id>http://bl-gs.github.io/2023/09/01/RISCV-Supervisor-Level%20ISA/</id>
    <published>2023-09-01T02:11:18.600Z</published>
    <updated>2023-09-01T07:27:13.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Supervisor-Registers"><a href="#Supervisor-Registers" class="headerlink" title="Supervisor Registers"></a>Supervisor Registers</h2><h3 id="Supervisor-Status-Register-sstatus"><a href="#Supervisor-Status-Register-sstatus" class="headerlink" title="Supervisor Status Register (sstatus)"></a>Supervisor Status Register (<code>sstatus</code>)</h3><p><code>sstatus</code> 是一个 SXLEN 位的可读写寄存器，是 <code>mstatus</code> 寄存器的子集</p><table><thead><tr><th>Field</th><th>Function</th></tr></thead><tbody><tr><td>SPP</td><td>指示进入 S-mode 之前的特权级，0 为 U-mode，否则为 1</td></tr><tr><td>SIE</td><td>使能 S-mode 下的所有中断；在 U-mode 下无视该值，默认开启</td></tr><tr><td>SPIE</td><td>指示陷入 S-mode 之前，supervisor 的中断是否被开启</td></tr><tr><td>UXL</td><td>控制 U-mode 下的 XLEN，即 UXLEN</td></tr><tr><td>MXR</td><td>访问虚拟内存时，读取的特权级要求，0 时只有 readable 的 page 能成功，1 时 executable 的 page 也能读取</td></tr><tr><td>SUM</td><td>访问虚拟内存时，读写的特权级要求，0 时访问 U-mode 可访问的页会失败，1 时能成功。Note S-mode 从不会执行用户页上的代码，不管 SUM 位</td></tr><tr><td>UBE</td><td>控制用户态内存访问的大小端</td></tr></tbody></table><h3 id="Supervisor-Trap-Vector-Base-Address-Register-stvec"><a href="#Supervisor-Trap-Vector-Base-Address-Register-stvec" class="headerlink" title="Supervisor Trap Vector Base Address Register (stvec)"></a>Supervisor Trap Vector Base Address Register (<code>stvec</code>)</h3><p><code>stvec</code> 是一个 SXLEN 位的可读写寄存器，保存 trap vector configuration</p><table><thead><tr><th>Field</th><th>Function</th></tr></thead><tbody><tr><td>BASE</td><td>可以是虚拟地址或者物理地址，指向 trap 处理函数</td></tr><tr><td>MODE</td><td>0 表示 Direct 访问，所有异常发生都会将 PC 设置为 BASE；1 表示 Vector 访问，同步中断会将 PC 设置为 BASE + 4 $\times$ cause</td></tr></tbody></table><h3 id="Supervisor-Interrupt-Register-sip-and-sie"><a href="#Supervisor-Interrupt-Register-sip-and-sie" class="headerlink" title="Supervisor Interrupt Register (sip and sie)"></a>Supervisor Interrupt Register (<code>sip</code> and <code>sie</code>)</h3><p><code>sip</code> 寄存器是一个 SXLEN 位的可读写寄存器，包括了被悬置的中断信息</p><p><code>sie</code> 寄存器是一个 SXLEN 位的可读写寄存器，包括了中断使能位</p><p>不同中断对应寄存器上不同位。在 S-mode，只有在 <code>sstatus</code> 寄存器 SIE 为 1 同时 <code>sie</code> 上对应中断位使能的时候，才能发生中断。</p><table><thead><tr><th>Field</th><th>Function</th></tr></thead><tbody><tr><td>SEIE&#x2F;SEIP</td><td>外部中断</td></tr><tr><td>STIE&#x2F;STIP</td><td>时钟中断</td></tr><tr><td>SSIE&#x2F;SSIP</td><td>软件中断</td></tr></tbody></table><h3 id="Supervisor-Timers-and-Performance-Counters"><a href="#Supervisor-Timers-and-Performance-Counters" class="headerlink" title="Supervisor Timers and Performance Counters"></a>Supervisor Timers and Performance Counters</h3><p>和用户层软件用的相同的硬件性能监视器设施，包括 <code>time</code>、<code>cycle</code>、<code>instret</code> CSRs</p><h3 id="Counter-Enable-Register-scounteren"><a href="#Counter-Enable-Register-scounteren" class="headerlink" title="Counter-Enable Register (scounteren)"></a>Counter-Enable Register (<code>scounteren</code>)</h3><p><code>scounteren</code> 是一个 32 位的寄存器，控制 U-mode 下硬件性能监视计数器</p><h3 id="Supervisor-Scratch-Register-sscratch"><a href="#Supervisor-Scratch-Register-sscratch" class="headerlink" title="Supervisor Scratch Register (sscratch)"></a>Supervisor Scratch Register (<code>sscratch</code>)</h3><p><code>sscratch</code> 是一个 SXLEN 位的可读写寄存器，在执行用户态程序时，用来保存一个指向硬件线程独有的 supervisor context 指针。</p><p>在 trap 处理函数开始，<code>sscratch</code> 和用户寄存器交换，从而提供初始化工作寄存器</p><h3 id="Supervisor-Exception-Program-Counter-sepc"><a href="#Supervisor-Exception-Program-Counter-sepc" class="headerlink" title="Supervisor Exception Program Counter (sepc)"></a>Supervisor Exception Program Counter (<code>sepc</code>)</h3><p><code>sepc</code> 是一个 SXLEN 位的可读写寄存器。其最低位一直是 0。其用于保存所有有效虚拟地址，在陷入到 S-mode 时，用于记录发生中断的指令虚拟地址。</p><h3 id="Supervisor-Cause-Register-scause"><a href="#Supervisor-Cause-Register-scause" class="headerlink" title="Supervisor Cause Register (scause)"></a>Supervisor Cause Register (<code>scause</code>)</h3><p><code>scause</code> 是一个 SXLEN 位的可读写寄存器，在陷入 S-mode 时，用于记录造成陷入的原因。</p><h3 id="Supervisor-Trap-Value-Register-stval"><a href="#Supervisor-Trap-Value-Register-stval" class="headerlink" title="Supervisor Trap Value Register (stval)"></a>Supervisor Trap Value Register (<code>stval</code>)</h3><p><code>stval</code> 是一个 SXLEN 位的可读写寄存器，在陷入 S-mode 时，写入跟异常相关的信息，辅助异常处理。</p><h3 id="Supervisor-Environment-Configuration-Register-senvcfg"><a href="#Supervisor-Environment-Configuration-Register-senvcfg" class="headerlink" title="Supervisor Environment Configuration Register (senvcfg)"></a>Supervisor Environment Configuration Register (<code>senvcfg</code>)</h3><p><code>senvcfg</code> 是一个 SXLEN 位的可读写寄存器，控制 U-mode 下执行环境的特征</p><table><thead><tr><th>Field</th><th>Function</th></tr></thead><tbody><tr><td>FIOM</td><td>为 1，在用户态下执行的 FENCE 指令会被修改，对设备 IO 的访问的排序要求和主存访问的配许要求（待补充）</td></tr><tr><td>CBIE</td><td>在 Zicboz 扩展中使用</td></tr><tr><td>CBCFE</td><td>在 Zicbom 扩展中使用</td></tr><tr><td>CBZE</td><td>在 Zicbom 扩展中使用</td></tr></tbody></table><h3 id="Supervisor-Address-Translation-and-Protection-Register-satp"><a href="#Supervisor-Address-Translation-and-Protection-Register-satp" class="headerlink" title="Supervisor Address Translation and Protection Register (satp)"></a>Supervisor Address Translation and Protection Register (<code>satp</code>)</h3><p><code>satp</code> 寄存器是一个 SXLEN 位的可读写寄存器，控制 S-mode 下的地址翻译和保护。其保存根页表的物理页号。</p><table><thead><tr><th>Field</th><th>Function</th></tr></thead><tbody><tr><td>PPN</td><td>根页表的物理页号</td></tr><tr><td>ASID</td><td>地址空间 ID</td></tr><tr><td>MODE</td><td>选择当前地址翻译的方式（Bare, Sv39, Sv48, Sv57)</td></tr></tbody></table><h2 id="Supervisor-Instructions"><a href="#Supervisor-Instructions" class="headerlink" title="Supervisor Instructions"></a>Supervisor Instructions</h2><h3 id="SRET"><a href="#SRET" class="headerlink" title="SRET"></a>SRET</h3><p>在处理完陷入事件后返回。详见异常处理</p><h3 id="Supervisor-Memory-Management-Fence-Instruction"><a href="#Supervisor-Memory-Management-Fence-Instruction" class="headerlink" title="Supervisor Memory-Management Fence Instruction"></a>Supervisor Memory-Management Fence Instruction</h3><p>SFENCE.VMA 指令用来同步所有对内存数据的更新，因此执行该指令可能造成一些隐式的读写，这些隐式的读写并不一定遵守显式的读写操作。</p><p>该指令保证其之前的所有写操作对应当前的硬件线程可见，效果仅限当前硬件线程。在指令中还能指定 ASID 和 VADDR，从而使地址翻译缓存中的特定条目失效。</p><ul><li>$ASID &#x3D; 0 \and VAddr &#x3D; 0$，排序所有地址空间，所有层页表的读写；还使所有地址空间所有地址翻译缓存条目失效</li><li>$ASID &#x3D; 0 \and VAddr \neq 0$，排序指定地址空间，所有层页表的读写；还使指定地址空间所有地址翻译缓存条目失效</li><li>$ASID \neq 0 \and VAddr &#x3D; 0$，排序所有地址空间，指定地址所在叶子页表的读写；还使所有地址空间指定地址所在叶子页表翻译缓存条目失效</li><li>$ASID \neq 0 \and VAddr \neq 0$，排序指定地址空间，指定地址所在叶子页表的读写；还使指定地址空间指定地址所在叶子页表翻译缓存条目失效</li></ul><p>在地址无效时，不会引起异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Supervisor-Registers&quot;&gt;&lt;a href=&quot;#Supervisor-Registers&quot; class=&quot;headerlink&quot; title=&quot;Supervisor Registers&quot;&gt;&lt;/a&gt;Supervisor Registers&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/categories/RISC-V/"/>
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/tags/RISC-V/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/tags/Hardware/"/>
    
    <category term="Privileged mode" scheme="http://bl-gs.github.io/tags/Privileged-mode/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V Trap</title>
    <link href="http://bl-gs.github.io/2023/08/31/RISCV-Trap/"/>
    <id>http://bl-gs.github.io/2023/08/31/RISCV-Trap/</id>
    <published>2023-08-31T14:26:47.147Z</published>
    <updated>2023-08-31T15:07:07.696Z</updated>
    
    <content type="html"><![CDATA[<p>RISC-V 将中断分为 <strong>软件中断</strong>、<strong>计时器中断</strong>、<strong>外部中断</strong>、<strong>中断和调试中断</strong>。</p><p>RISC-V 当前并不支持硬件层面的 trap 嵌套，只能通过软件实现。</p><h2 id="Trap-处理"><a href="#Trap-处理" class="headerlink" title="Trap 处理"></a>Trap 处理</h2><p>在程序执行过程中触发了特定条件，产生中断：</p><ul><li>保存当前运行状态</li><li>依据对应特权级的 <code>ideleg</code> 和 <code>edeleg</code> CSR，确定处理该 trap 所需要的特权级，然后跳转到指定的 trap 处理函数所在的位置（由 <code>mtvec</code> 指定）</li><li>设置 epc、cause、tval、tinst 等 CSR 的值</li><li>处理 trap</li><li>调用 <code>mret</code>、<code>sret</code> 指令返回，恢复 trap 触发之前的状态</li></ul><h3 id="保存当前运行状态"><a href="#保存当前运行状态" class="headerlink" title="保存当前运行状态"></a>保存当前运行状态</h3><p>用栈保存通用寄存器的值</p><p>xstatus(x &#x3D; m, s, h) CSR 负责保存 trap 发生时的中断使能、特权级等信息。其中 xIE, xPIE, xPP 共同构成一个可以保存 trap 前中断使能、特权级情况的栈。</p><p>栈的深度决定了 RISC-V 当前并不支持硬件层面的 trap 嵌套，但是可以通过软件方式保存现场、开启中断使能来实现。</p><p>在添加了 H 扩展后，还需要 <code>hstatus</code> 来辅组保存 Guest 的信息。</p><h3 id="跳转到处理程序"><a href="#跳转到处理程序" class="headerlink" title="跳转到处理程序"></a>跳转到处理程序</h3><p>主要涉及 <code>mtvec</code> CSR，具有向量化和非向量化两种模式。CSR 包括两部分：BASE 和 MODE，前者指定处理函数的基地址，后者指定跳转的模式：</p><ul><li>直接跳转(MODE &#x3D; 0)：直接跳转到基地址进行 trap 处理</li><li>向量化跳转(MODE &#x3D; 1)：所有在 M-mode 处理的同步异常直接跳转到基地址，对于外部中断，设置 PC &#x3D; BASE + 4 * cause.</li></ul><h3 id="中断使能、中断悬置"><a href="#中断使能、中断悬置" class="headerlink" title="中断使能、中断悬置"></a>中断使能、中断悬置</h3><p>主要涉及 ie 和 ip 两个 CSR。在 mip 和 mie 中分别记录了 Machine 和 Supervisor 的 External、Timer、Software Interrupts 的使能以及挂起情况，处理优先级为 MEI, MSI, MTI, SEI, SSI, STI。</p><p>仅在同时满足如下条件时，trap 才可以在 M-Mode 处理：</p><ol><li>当前特权级为 M，且 mstatus.MIE&#x3D;1，或当前特权级比 M 更低；</li><li>mip, mie CSR 均被设置为 mcause 的值；</li><li>若 mideleg CSR 存在则其未被修改为 mcause 的值。</li></ol><p>除了 M-Mode 之外，其他特权模式也都有对应的中断使能和等待 CSR，如下表所示，其结构与 mie, mip 相似，如下表所示：</p><table><thead><tr><th align="left">Privilege</th><th align="left">xie</th><th align="left">xip</th><th align="left">hgeip</th><th align="left">hgeie</th></tr></thead><tbody><tr><td align="left">S</td><td align="left">sie</td><td align="left">sip</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">HS</td><td align="left">hie</td><td align="left">hip, hvip</td><td align="left">hgeip</td><td align="left">hgeie</td></tr><tr><td align="left">VS</td><td align="left">vsie</td><td align="left">vsip</td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="中断信息"><a href="#中断信息" class="headerlink" title="中断信息"></a>中断信息</h3><h4 id="epc"><a href="#epc" class="headerlink" title="epc"></a>epc</h4><p>mepc, sepc 分别用于在 M-Mode 和 S-Mode 下处理 trap 时记录原程序发生 trap 时的地址；vsepc 则是用于 Guest 内部的中断处理的，其功能与仅支持 S 扩展时的 sepc 几乎相同。</p><h4 id="cause"><a href="#cause" class="headerlink" title="cause"></a>cause</h4><p>cause 用于记录当 trap 被交由 M-Mode 处理时该 trap 的具体类型。该 CSR 包含 Interrupt 和 Exception Code 两个部分，前者用于记录本次处理的 trap 是否为 Interrupt，是则置 1，否则置 0，后者用于记录上一次处理的 trap 的具体编码。</p><p>在 trap 处理完成之后，Exception Code 的值将会被修改为本次 trap 的类型编码，这个值来自于程序本身，如果是页错误（page fault）等需要保存额外信息的异常，tval 将会被修改。此外处理中断还有优先级关系。</p><h4 id="tval"><a href="#tval" class="headerlink" title="tval"></a>tval</h4><p>tval 用于辅助软件进行 trap 处理。tval 的值要么是 0 要么被写入异常相关的特定信息。如果硬件指定了所有异常都不会导致 tval 被写入非 0 值，那么该寄存器将始终是只读的 0。</p><p>tval 被写入非 0 值大致包含以下情况，即异常类型为断点（breakpoint）、地址错位（address-misaligned）、访问错误（access-fault）和页错误（page-fault），此时 tval 将会被写入出错的虚拟地址，即便是对物理内存的访问出错也是如此。这样的设计对于大多数的实现来说可以大大减少数据通路的访问代价。尤其是需要进行 page-table walk 的实现。</p><p>对于 access-fault 和 page-fault 异常而言，epc CSR 将会被用于保存导致异常的指令地址，而 tval 则用于保存导致上述异常的指令访问的虚拟地址。</p><h4 id="mtinst，htinst"><a href="#mtinst，htinst" class="headerlink" title="mtinst，htinst"></a>mtinst，htinst</h4><h5 id="mtinst-htinst"><a href="#mtinst-htinst" class="headerlink" title="mtinst, htinst"></a>mtinst, htinst</h5><p>mtinst 会在 trap 发生后并进入 M-Mode 时，写入一个发生 trap 的指令值，或者直接置 0，该信息将用于协助软件处理 trap。htinst 则协助处理 HS-Mode 的 trap。二者都会被自动写入。它们的值规定如下：</p><ul><li>0；</li><li>导致发生 trap 的指令的转换结果；</li><li>非标准的导致 trap 的指令的指定值；</li><li>特殊的伪指令。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>添加 H 扩展之后，RISC-V ISA 中与 trap 相关的 CSR 列表如下。需要注意的是，在进行 trap 处理时，需要如上节所分析的那样，确定在什么特权级下使用哪些 CSR 进行处理。</p><table><thead><tr><th align="left">Function</th><th align="left">Machine</th><th align="left">Supervisor</th><th align="left">Hypervisor</th><th align="left">Virtual Supervisor</th></tr></thead><tbody><tr><td align="left">Trap Vector Base Address</td><td align="left">mtvec</td><td align="left">stvec</td><td align="left"></td><td align="left">vstvec</td></tr><tr><td align="left">Trap Delegation</td><td align="left">medeleg and mideleg</td><td align="left"></td><td align="left">hedeleg, hideleg</td><td align="left"></td></tr><tr><td align="left">Interrupt</td><td align="left">mip, mie</td><td align="left">sip, sie</td><td align="left">hvip, hip, hie</td><td align="left">vsip, vsie</td></tr><tr><td align="left">Hypervisor Guest External Interrupt</td><td align="left"></td><td align="left"></td><td align="left">hgeip, hgeie</td><td align="left"></td></tr><tr><td align="left">Exception Program Counter</td><td align="left">mepc</td><td align="left">sepc</td><td align="left"></td><td align="left">vsepc</td></tr><tr><td align="left">Cause</td><td align="left">mcause</td><td align="left">scause</td><td align="left"></td><td align="left">vscause</td></tr><tr><td align="left">Trap Value</td><td align="left">mtval</td><td align="left">stval</td><td align="left">htval</td><td align="left">vstval</td></tr><tr><td align="left">Trap Instruction</td><td align="left">mtinst</td><td align="left"></td><td align="left">htinst</td><td align="left"></td></tr><tr><td align="left">Status</td><td align="left">mstatus, mstatush</td><td align="left">sstatus</td><td align="left">hstatus</td><td align="left">vsstatus</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RISC-V 将中断分为 &lt;strong&gt;软件中断&lt;/strong&gt;、&lt;strong&gt;计时器中断&lt;/strong&gt;、&lt;strong&gt;外部中断&lt;/strong&gt;、&lt;strong&gt;中断和调试中断&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;RISC-V 当前并不支持硬件层面的 trap </summary>
      
    
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/categories/RISC-V/"/>
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/tags/RISC-V/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/tags/Hardware/"/>
    
    <category term="Privileged mode" scheme="http://bl-gs.github.io/tags/Privileged-mode/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V Exception</title>
    <link href="http://bl-gs.github.io/2023/08/31/RISCV-Exception/"/>
    <id>http://bl-gs.github.io/2023/08/31/RISCV-Exception/</id>
    <published>2023-08-31T12:09:43.432Z</published>
    <updated>2023-08-31T14:25:55.583Z</updated>
    
    <content type="html"><![CDATA[<p>异常的定义很多种，但是大都分为：</p><ul><li><strong>同步异常：</strong>执行某个指令序列，在某条指令处能够确切引起异常</li><li><strong>异步异常</strong>：与执行的指令序列无关，而与外部的中断事件有关</li></ul><p>也有将同步异常称为异常，将异步异常称为中断的。</p><p>RISC-V 将中断分为 <strong>软件中断</strong>、<strong>计时器中断</strong>、<strong>外部中断</strong>、<strong>中断和调试中断</strong></p><h2 id="非虚拟化场景"><a href="#非虚拟化场景" class="headerlink" title="非虚拟化场景"></a>非虚拟化场景</h2><p>在任何时候，一个 RISC-V 的 hart 都会运行在一个权限模式当中。在不开启 H 扩展的条件下，共有三种特权模式：<strong>User (U-mode)、Supervisor (S-mode)、Machine (M-mode)</strong></p><h3 id="CSRs"><a href="#CSRs" class="headerlink" title="CSRs"></a>CSRs</h3><p>与异常相关的空置状态寄存器共有 8 个：</p><ul><li><strong>mcause (Machine Exception Cause)</strong> 记录发生异常的原因</li><li><strong>mtvec (Machine Trap Vector Base-Address Register)</strong> 记录发生异常时处理器需要跳转到的异常处理程序的地址。mtvec 有两种模式。一种是直接模式，直接跳转到 mtvec 中的基地址执行；另一种是向量模式，根据 mcause 中的中断类型跳转到对应的中断处理程序首地址中执行。</li><li><strong>mepc (Machine Exception PC)</strong> 记录发生异常时的指令地址</li><li><strong>mie (Machine Interrupt Enable)</strong> 记录处理器要处理和屏蔽的中断</li><li><strong>mip (Machine interrupt Pending)</strong> 记录目前正在等待处理的中断</li><li><strong>mstatus (Machine Status)</strong> 记录中断前、中断时、中断后的全局中断信息。</li><li><strong>mtval (Machine Trap Value)</strong> 保存异常的附加信息</li><li><strong>mscratch (Machine Scratch)</strong> 它暂时存放一个字大小的数据。在 U 模式下，mscratch 保存 M 模式下栈的地址；在 M 模式下，mscratch 的值为 0。可以在发生异常时通过 mscratch 中的值判断异常前程序是否处于 M 模式。为了能够执行 M 模式的中断处理流程，很可能需要使用栈，而程序当前的用户栈是不安全的。因此，我们还需要一个预设的安全的栈空间，存放在这里。</li></ul><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>当一个 hart 发生异常时：</p><ul><li>将异常发生时所处的特权级保存在 mstatus.MPP 中，再将权限模式更改为 M 模式。</li><li>将异常发生前的 mstatus.MIE 保存在 mstatus.MPIE 当中</li><li>把 mstatus.MIE 置 0 以关中断。</li><li>根据异常来源设置 mcause</li><li>将异常的附加信息写入 mtval</li><li>将异常指令的 PC 保存在 mepc 中，将 PC 设置为 mtvec 保存的异常处理程序入口<ul><li>对于同步异常，mepc 指向导致异常的指令</li><li>对于外部中断，mepc 指向中断处理后应该恢复执行的指令，一般为 mepc + 4</li></ul></li></ul><p>执行异常处理程序，然后调用 MRET&#x2F;SRET 指令退出异常处理程序</p><ul><li>将异常发生前的 mstatus 的状态恢复</li><li>将 mstatus.MPIE 复制到 mstatus.MIE 来恢复之前的中断使能设置</li><li>将权限模式设置为 mstatus.MPP 域中的值</li><li>从 mepc 中保存的地址处恢复执行</li></ul><h3 id="异常委托"><a href="#异常委托" class="headerlink" title="异常委托"></a>异常委托</h3><p>主要与两个寄存器相关：<strong>medeleg</strong> (Machine Exception Delegation) 和 <strong>mideleg</strong> (Machine Interrupt Delegation)</p><p>默认情况下，发生异常后 hart 会进入 M 模式执行异常处理程序。但是如何在 S 模式下完成异常处理，同时不需要再次对 Supervisor OS 引起异常。通过 <strong>异常委托机制</strong>，能够选择性地将异常绕过 M 模式，交予 S 模式处理。</p><p>与 mip 和 mie 的布局一样，medeleg 和 mideleg 中的位置对应于 mcause 中的异常编码值。在 medeleg 中使能该异常的委托，发生异常时将 mideleg 对应异常位置 1，则该中断会移交 S 模式地异常处理程序。当然，这个异常能够被 S 模式屏蔽掉（sie 寄存器）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;异常的定义很多种，但是大都分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同步异常：&lt;/strong&gt;执行某个指令序列，在某条指令处能够确切引起异常&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步异常&lt;/strong&gt;：与执行的指令序列无关，而与外部的中断事件有关&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/categories/RISC-V/"/>
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/tags/RISC-V/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/tags/Hardware/"/>
    
    <category term="Privileged mode" scheme="http://bl-gs.github.io/tags/Privileged-mode/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V H Extension</title>
    <link href="http://bl-gs.github.io/2023/08/31/RISCV-H%20Extension/"/>
    <id>http://bl-gs.github.io/2023/08/31/RISCV-H%20Extension/</id>
    <published>2023-08-31T12:09:00.703Z</published>
    <updated>2023-08-31T14:16:50.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="H-扩展"><a href="#H-扩展" class="headerlink" title="H 扩展"></a>H 扩展</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>在添加 H 扩展后。系统包含了硬件、Supervisor、OS、APP 四层。硬件与 supervisor 之间的通信与 S 级架构下硬件与 OS 的通信类似，可以使用相同的 SBI；但 supervisor 与 Guest 之间的通信则需要额外的实现。值得一提的是，hypervisor 除了可以是单独实现的管理器之外，还可以是具备管理多个 Guest 的能力的 OS。</p><p>也就是一个完整的系统可以有 M-mode、HS-mode、VS-mode、VU-mode，也可以只是 M-mode、HS-mode、U-mode 。</p><p>在寄存器 <code>misa</code> 寄存器设置 H 扩展支持位</p><h2 id="Additional-Privilege-Mode"><a href="#Additional-Privilege-Mode" class="headerlink" title="Additional Privilege Mode"></a>Additional Privilege Mode</h2><table><thead><tr><th>Virtualization Mode</th><th>Abbreviation</th><th>Name</th><th>Two-Stage Translation</th></tr></thead><tbody><tr><td>0</td><td><strong>U-mode</strong></td><td>User mode</td><td>Off</td></tr><tr><td>0</td><td><strong>HS-mode</strong></td><td>Hypervisor-extended supervisor mode</td><td>Off</td></tr><tr><td>0</td><td><strong>M-mode</strong></td><td>Machine mode</td><td>Off</td></tr><tr><td>1</td><td><strong>VU-mode</strong></td><td>Virtual user mode</td><td>On</td></tr><tr><td>1</td><td><strong>VS-mode</strong></td><td>Virtual supervisor mode</td><td>On</td></tr></tbody></table><p>HS 模式和 S 模式行为基本一致，除此之外还增加了一些指令和寄存器辅组地址翻译和 VS 模式。一般的 S 模式的操作系统无需修改就能在 HS 和 VS 上运行。</p><p>在 <code>misa</code> CSR 上的第 7 位设置，即可开启虚拟化模式，要么处于 VU 要么 VS 模式。否则，处于 M 或者 HS 或者 U 模式。</p><h2 id="Additional-Registers"><a href="#Additional-Registers" class="headerlink" title="Additional Registers"></a>Additional Registers</h2><p>对应于 S 模式的 CSR，添加了支持 HS 模式的 CSR，从而管理 VS 模式的地址翻译和客户机行为：</p><ul><li><strong>HS mode</strong>: hstatus, hedeleg, hideleg, hvip, hip, hie, hgeip, hgeie, henvcfg, henvcfgh, hcounteren, htimedelta, htimedeltah, htval, htinst, hgatp.</li><li><strong>VS mode</strong>: vsstatus, vsip, vsie, vstvec, vsscratch, vsepc, vscause, vstval, vsatp</li><li><strong>M mode</strong>: mtval2, mtinst</li></ul><p>在 V &#x3D; 0 时，正常访问 CSR；在 V &#x3D; 1 时，将用对应的 VS CSR 代替 HS CSR</p><h2 id="Additional-Instructions"><a href="#Additional-Instructions" class="headerlink" title="Additional Instructions"></a>Additional Instructions</h2><ul><li>Load and Store<ul><li><code>HLV.width</code> 不同 width 对应 LB、LBU、LH、LHU、LW、LWU 和 LD，</li><li><code>HLVX.HU/WU</code> 和 HLV.HU 和 HLV.WU 相似，除了在地址翻译的时候，要求执行权限而不是读权限</li><li><code>HSV.width</code> 不同 width 对应 SB、SH、SW和 SD</li></ul></li><li>Fence<ul><li>HFENCE.VVMA</li><li>HFENCE.GVMA</li></ul></li></ul><h2 id="Additional-Exception"><a href="#Additional-Exception" class="headerlink" title="Additional Exception"></a>Additional Exception</h2><p> <code>hvip</code> 寄存器断言(assert) VS 模式的中断（外部中断、时钟中断、软件中断），<code>hip</code> 寄存器指示被悬置的中断，<code>hie</code> 寄存器指示启用的中断</p><p><code>hgeip</code> 和 <code>hgeie</code> 指示客户端的外部中断的悬置和启用</p><ul><li><h2 id="virtual-instruction-exception-在-V-1-时，对-VS-CSR-的直接读写会引起该异常，在-U-模式下的话则会引起-illegal-instruction-exception-在寄存器-hstatus-的-VTVM-1-时，在-VS-模式下执行-SFENCE-VMA-和-SINVAL-VMA，或者访问-CSR-satp-会导致该异常"><a href="#virtual-instruction-exception-在-V-1-时，对-VS-CSR-的直接读写会引起该异常，在-U-模式下的话则会引起-illegal-instruction-exception-在寄存器-hstatus-的-VTVM-1-时，在-VS-模式下执行-SFENCE-VMA-和-SINVAL-VMA，或者访问-CSR-satp-会导致该异常" class="headerlink" title="virtual instruction exception:  - 在 V &#x3D; 1 时，对 VS CSR 的直接读写会引起该异常，在 U 模式下的话则会引起 illegal instruction exception  - 在寄存器 hstatus 的 VTVM &#x3D; 1 时，在 VS 模式下执行 SFENCE.VMA 和 SINVAL.VMA，或者访问 CSR satp 会导致该异常"></a><strong>virtual instruction exception</strong>:<br>  - 在 V &#x3D; 1 时，对 VS CSR 的直接读写会引起该异常，在 U 模式下的话则会引起 <strong>illegal instruction exception</strong><br>  - 在寄存器 <code>hstatus</code> 的 VTVM &#x3D; 1 时，在 VS 模式下执行 SFENCE.VMA 和 SINVAL.VMA，或者访问 CSR <code>satp</code> 会导致该异常</h2></li><li><strong>guest page fault</strong>: </li><li><h2 id="trap-在寄存器-hstatus-的-HU-0-时，HLV、HLVX-和-HSV-会导致-illegal-instruction-trap"><a href="#trap-在寄存器-hstatus-的-HU-0-时，HLV、HLVX-和-HSV-会导致-illegal-instruction-trap" class="headerlink" title="trap:  - 在寄存器 hstatus  的 HU &#x3D; 0 时，HLV、HLVX 和 HSV 会导致 illegal instruction trap"></a><strong>trap</strong>:<br>  - 在寄存器 <code>hstatus </code> 的 HU &#x3D; 0 时，HLV、HLVX 和 HSV 会导致 illegal instruction trap</h2></li></ul><p>假如 <code>hideleg</code> 中对应异常的位存在，一个通过 <code>mideleg</code> 被委托到 HS 模式的异常会被进一步委托到 VS 模式</p><h2 id="Modified-Registers"><a href="#Modified-Registers" class="headerlink" title="Modified Registers"></a>Modified Registers</h2><ul><li><strong>M mode</strong>：mstatus, mstatush, mideleg, mip, mie</li></ul><h2 id="Two-Stage-Address-Translation"><a href="#Two-Stage-Address-Translation" class="headerlink" title="Two-Stage Address Translation"></a>Two-Stage Address Translation</h2><p>虚拟机中虚拟地址的访问需要经历 VS 和 G 两个阶段的转换，这两个阶段分别由 CSR <code>vsatp</code> 和 <code>hgatp</code> 控制，完成从 GVA 到 GPA 再到 HPA 的转换，分别为 VS-Stage 和 G-Stage</p><h3 id="GPA-Translation"><a href="#GPA-Translation" class="headerlink" title="GPA Translation"></a>GPA Translation</h3><h3 id="Guest-Page-Faults"><a href="#Guest-Page-Faults" class="headerlink" title="Guest-Page Faults"></a>Guest-Page Faults</h3><h3 id="Fence"><a href="#Fence" class="headerlink" title="Fence"></a>Fence</h3><ul><li><code>HFENCE.VVMA</code> 应用于 VS 层的内存数据，由 CSR <code>vsatp</code> 控制</li><li><code>HFENCE.GVMA</code> 应用于 客户机 的内存管理数据，由 CSR <code>hgatp</code> 控制，使用 VMID 而非 ASID</li></ul><p>HFENCE.xVMA 和 SFENCE.VMA 基本相同，不同支持在于指令有效时所在的特权级不同，所处理的特权级也不同。SFENCE.VMA 则只应用于当前特权级对应的内存管理数据，由当前特权级对应的 <code>satp</code> 管理</p><table><thead><tr><th>Inst</th><th>SFENCE.VMA</th><th>HFENCE.VVMA</th><th>HFENCE.GVMA</th></tr></thead><tbody><tr><td>生效所需特权级</td><td>M</td><td>M&#x2F;HS</td><td>HS(mstatus.TVM &#x3D; 0)&#x2F;M</td></tr><tr><td>作用于</td><td>S</td><td>VS</td><td>HS</td></tr><tr><td>对应的 atp 寄存器</td><td>当前特权级的 atp 寄存器 <code>satp</code>&#x2F;<code>vsatp</code></td><td><code>vsatp</code></td><td><code>hgatp</code></td></tr><tr><td>指令作用</td><td>to guarantee writing finishes before reading; to invalidate TLB</td><td>much the same as temporarily entering VS-mode and executing <code>SFENCE.VMA</code>; applies only to a single virtual machine, identified by the setting of <code>hgatp.VMID</code></td><td>to guarantee stores of current hart finishes before reading of the guest hart</td></tr></tbody></table><h2 id="Traps"><a href="#Traps" class="headerlink" title="Traps"></a>Traps</h2><p>中断陷入 HS 模式的条件：</p><ul><li>现在处于 HS 模式 并且 <code>sstatus</code> 寄存器的 SIE 位；或者当前特权级比 HS 模式低</li><li><code>sip</code> 和 <code>sie</code> 中相应中断的位被设置，或者 <code>hip</code> 和 <code>hie</code> 寄存器</li><li><code>hideleg</code> 寄存器中相应中断的位没有被设置</li></ul><p>Trap 的原因记录在 <code>htval</code> 里面，<code>htinst</code> 记录造成陷入的指令</p><p>正常情况下，trap 都会导致 hart 转移到 M 模式，处理之后通过 mret 指令返回到原来的模式。通过委托机制，trap 可以通过 medeleg 和 mideleg 将其从 HS-mode 或者 VS-mode 委托给 HS-mode，通过hedeleg 和 hideleg 将异常从 VU-mode 委托给 VS-mode 。再 HS-mode 和 VS-mode 完成委托的 trap 后，通过 sret 返回 trap 之前的模式。</p><pre><code class="mermaid">graph TB    A[VU-mode] -- trap by hedeleg or hideleg --&gt; B[VS-mode]    B -- trap by medeleg or mideleg --&gt; C[HS-mode]    C -- trap by medeleg or mideleg --&gt; C    E[U-mode] -- trap by medeleg or mideleg --&gt; C    C --&gt; D[M-mode]</code></pre><p>虚拟化模式及特权级的切换对于 CSR 的修改包含如下情况：</p><p>trap 到 <strong>M-mode</strong>, V&#x3D;0, **<code>mstatus</code>**’s fields MPV (Machine Previous Virtualization), MPP (Machine Previous Previlige) 依据下表设置：</p><table><thead><tr><th align="left">Previous Mode</th><th align="left">mstatus.MPV</th><th align="left">mstatus.MPP</th></tr></thead><tbody><tr><td align="left">U-mode</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">HS-mode</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">M-Mode</td><td align="left">0</td><td align="left">3</td></tr><tr><td align="left">VU-mode</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">VS-mode</td><td align="left">1</td><td align="left">1</td></tr></tbody></table><p>并修改 <code>mstatus</code> 的 GVA, MIE, MPIE 位，修改 CSR <code>mepc</code>, <code>mcause</code>, <code>mtval</code>, <code>mtval2</code>, <code>mtinst</code>.</p><p>trap 到 <strong>HS-mode</strong>, V&#x3D;0, <strong><code>hstatus</code></strong> 的 MPV 和 MPP 位调整如下：</p><table><thead><tr><th align="left">Previous Mode</th><th align="left">hstatus.SPV</th><th align="left">hstatus.SPP</th></tr></thead><tbody><tr><td align="left">U-mode</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">HS-mode</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">VU-mode</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">VS-mode</td><td align="left">1</td><td align="left">1</td></tr></tbody></table><p>若 trap 前 V&#x3D;1，<code>hstatus.SPVP = sstatus.SPP</code>；若 trap 前 V&#x3D;0，保持不变。</p><p>trap 到 HS-mode 要求写 <code>hstatus.GVA</code>, <code>sstatus.SIE</code>, <code>sstatus.SPIE</code> 和 CSR <code>sepc</code>, <code>scause</code>, <code>stval</code>, <code>htval</code>, <code>htinst</code>。</p><p>trap 到 <strong>VS-mode</strong>，<code>vsstatus.SPP</code> 依照下表设置：</p><table><thead><tr><th align="left">Previous Mode</th><th align="left">vsstatus.SPP</th></tr></thead><tbody><tr><td align="left">VU-mode</td><td align="left">0</td></tr><tr><td align="left">VS-mode</td><td align="left">1</td></tr></tbody></table><p><code>hstatus</code>, <code>sstatus</code> 不修改，V&#x3D;1；写 <code>vsstatus.PIE</code>, <code>vsstatus.SPIE</code> 和 CSR <code>vsepc</code>, <code>vscause</code>, <code>vstval</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;H-扩展&quot;&gt;&lt;a href=&quot;#H-扩展&quot; class=&quot;headerlink&quot; title=&quot;H 扩展&quot;&gt;&lt;/a&gt;H 扩展&lt;/h1&gt;&lt;h2 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h</summary>
      
    
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/categories/RISC-V/"/>
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/tags/RISC-V/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/tags/Hardware/"/>
    
    <category term="Privileged mode" scheme="http://bl-gs.github.io/tags/Privileged-mode/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V Machine-Level ISA</title>
    <link href="http://bl-gs.github.io/2023/08/25/RISCV-Machine-Level%20ISA/"/>
    <id>http://bl-gs.github.io/2023/08/25/RISCV-Machine-Level%20ISA/</id>
    <published>2023-08-25T07:33:41.958Z</published>
    <updated>2023-08-26T02:09:36.521Z</updated>
    
    <content type="html"><![CDATA[<p>机器模式 Machine Level 在 RISC-V 系统中是最高特权级。M-mode 用来提供低等级的，对硬件的操作。系统的最初状态就是机器模式。</p><h2 id="Machine-Level-CSRs"><a href="#Machine-Level-CSRs" class="headerlink" title="Machine-Level CSRs"></a>Machine-Level CSRs</h2><h3 id="Machine-ISA-Register-misa"><a href="#Machine-ISA-Register-misa" class="headerlink" title="Machine ISA Register misa"></a>Machine ISA Register <code>misa</code></h3><p><code>misa</code> CSR 是一个 WARL 可读写寄存器，指示被支持的 ISA。这个寄存器一定得是可读的，但是可以通过返回 0 值表示 <code>misa</code> 寄存器仍未被实现。</p><p><img src="/source/images/Machine%20ISA%20Register%20misa.png" alt="Machine ISA register(misa)"></p><ul><li><em>MXL</em> 指示 native base integer ISA 的宽度 MXLEN (0-32，1-64，3-128)。可以是可写的从而支持多种 base ISA。在 misa 为 0 时，MXLEN 是一个固定值。</li><li><em>Extension</em> 域指示标准扩展的实现，每个 bit 对应一个扩展字母。</li></ul><p>其他细节详见说明书。</p><h3 id="Machine-Vendor-ID-Register-mvendorid"><a href="#Machine-Vendor-ID-Register-mvendorid" class="headerlink" title="Machine Vendor ID Register mvendorid"></a>Machine Vendor ID Register <code>mvendorid</code></h3><p><code>mvendorid</code> CSR 为 32 位制度寄存器，提供处理器核的 JEDEC manufacturer ID。该寄存器必须是可读的，可以返回 0 值表示未实现。</p><p><img src="/source/images/Machine%20Vendor%20ID%20Register%20mvendorid.png" alt="Machine Vendor ID Register (mvendorid)"></p><h3 id="Machine-Architecture-ID-Register-marchid"><a href="#Machine-Architecture-ID-Register-marchid" class="headerlink" title="Machine Architecture ID Register marchid"></a>Machine Architecture ID Register <code>marchid</code></h3><p><code>marchid</code> CSR 是宽度为 MXLEN 位的只读寄存器，指示基础微架构。该寄存器必须是可读的，可以返回 0 值表示未实现。<code>mvendorid</code> 和 <code>marchid</code> 寄存器唯一的指定微架构的类型。</p><p><img src="/source/images/Machine%20Architecture%20ID%20Register%20marchid.png" alt="Machine Architecture ID Register (marchid)"></p><h3 id="Machine-Implementation-ID-Register-mimpid"><a href="#Machine-Implementation-ID-Register-mimpid" class="headerlink" title="Machine Implementation ID Register mimpid"></a>Machine Implementation ID Register <code>mimpid</code></h3><p><code>marchid</code> CSR 是宽度为 MXLEN 位寄存器，指示处理器的实现版本。该寄存器必须是可读的，可以返回 0 值表示未实现。</p><p><img src="/source/images/Machine%20Implementation%20ID%20Register%20mimpid.png" alt="Machine Implementation ID Register (mimpid)"></p><h3 id="Hart-ID-Register-mhartid"><a href="#Hart-ID-Register-mhartid" class="headerlink" title="Hart ID Register mhartid"></a>Hart ID Register <code>mhartid</code></h3><p><code>mhartid</code> CSR 是宽度为 MXLEN 位的只读寄存器，指示该核上的硬件线程 ID。该寄存器必须是可读的，可以返回 0 值表示未实现。在执行系统中，这个 ID 必须是唯一的。</p><h3 id="Machine-Status-Registers-mstatus-and-mstatush"><a href="#Machine-Status-Registers-mstatus-and-mstatush" class="headerlink" title="Machine Status Registers mstatus and mstatush"></a>Machine Status Registers <code>mstatus</code> and <code>mstatush</code></h3><p><code>mstatus</code> CSR 是宽度为 MXLEN 的可读写寄存器，在 RV32 和 RV64 中有所不同。其跟踪而且控制 hart 现在的状态。Supervisor 下的 <code>sstatus</code> 寄存器对应于该寄存器。</p><p><img src="/source/images/Machine%20Status%20Registers%20mstatus.png" alt="Machine Status Registers (mstatus)"></p><p><img src="/source/images/Machine%20Status%20Registers%20mstatush.png" alt="Machine Status Registers (mstatush)"></p><ul><li><code>MIE</code> 和 <code>SIE</code> 分别启动 M-mode 和 S-mode 的中断，低等级中断会被高等级屏蔽掉。</li><li><code>MPIE</code> 和 <code>SPIE</code> 分别指示 M-mode 和 S-mode 下陷入 trap 之前的 <code>MIE</code>&#x2F;<code>SIE</code> 寄存器。</li><li><code>MPP</code> 和 <code>SPP</code> 分别指示 trap 之前的特权级</li></ul><p>在陷入发生时，从特权级 y 到 特权级 x，<code>xPIE</code> 被设置为 <code>xIE</code> 寄存器的值，<code>xIE</code> 被设置为 0，<code>xPP</code> 被设置为 y</p><p>MRET 和 SRET 指令分别用来从 M-mode 和 S-mode 退出陷入。执行时，假设 <code>xPP</code> 值为 y，<code>xIE</code> 被设置为 <code>xPIE</code> 的值，特权模式变为 y，<code>xPIE</code> 设置为 1，<code>xPP</code> 被设置为最低特权支持模式。假如 <code>xPP</code> 不是 M，则设置 MPRV &#x3D; 0</p><p><code>MPRV</code> bit 修改有效特权模式，比如 load 和 store 执行的特权级。在 <code>MPRV</code> &#x3D; 0 时，load 和 store 和正常一样，使用当前特权模式的翻译和保护机制。在 <code>MPRV</code> &#x3D; 1 时，load 和 store 地址也被翻译和保护，尽管当前特权模式在 <code>MPP</code> 设置。</p><p><code>MBE</code>、<code>SBE</code> 和 <code>UBE</code> 控制了内存访问的字节序，但是获取指令时一定是小端序。</p><p><code>TVM</code> 位支持截取 supervisor 虚拟内存的管理操作。在 TVM &#x3D; 1 时，在 S-mode 下对 satp CSR 的读写，或者执行 SFENCE.VMA 或者 SINVAL.VMA 指令，都会导致 <em>illegal instruction exception</em>。当 TVM &#x3D; 0 时，这些操作在 S-mode 下都是允许的。</p><p><code>TW</code> 位支持截取 WFI 指令。在 TW &#x3D; 0 时，WFI 指令可能执行在更低的特权模式下在不需要组织某些行为时。在 TW &#x3D; 1 时，如果 WFI 指令被执行在任意低特权模式，同时没有特殊的实现，WFI 指令会造成 <em>illegal instruction exception</em>。</p><p><code>TSR</code> 位能截取 supervisor exception return 指令 SRET。当 TSR &#x3D; 1，在 S-mode 下尝试执行 SRET 会导致 illegal instruction exception；当 TSR &#x3D; 0，这个操作能够在 S-mode 下执行。</p><p><code>FS[1:0]</code> ，<code>VS[1:0]</code> WARL 域和 <code>XS[1:0]</code> 只读域，通过设置和追踪当前浮点单元和任何其他用户模式扩展的状态，从而减少上下文保存恢复的开销。FS 记录浮点单元的状态，VS 记录向量扩展的状态，XS 记录额外用户态扩展的状态</p><p><code>SD</code> 位标识 FS、VS、XS域中是否有脏位需要保存。</p><h3 id="Machine-Trap-Vector-Base-Address-Register-mtvec"><a href="#Machine-Trap-Vector-Base-Address-Register-mtvec" class="headerlink" title="Machine Trap-Vector Base-Address Register mtvec"></a>Machine Trap-Vector Base-Address Register <code>mtvec</code></h3><p><code>mtvec</code> 寄存器是 MXLEN 位的读写寄存器，负责 trap vector 的配置，包括了一个向量基地址(BASE)和一个向量模式(MODE)</p><p><img src="/source/images/Machine%20Trap-Vector%20Base-Address%20Register%20mtvec.png" alt="Machine Trap-Vector Base-Address Register (mtvec)"></p><p>mtvec 一定要被实现，但是可以是个只读值。如果可写，寄存器的值可能根据实现有所不同。</p><p><img src="/source/images/Encoding%20of%20mtvec%20MODE%20field.png" alt="Encoding of mtvec MODE field"></p><ul><li>当 MODE &#x3D; Direct 时，所有机器模式的陷入导致 <strong>pc</strong> 设置为 BASE 对应的地址。</li><li>当 MODE &#x3D; Vectored 时，所有到机器模式的同步异常导致 <strong>pc</strong> 设置为 BASE 对应的地址，但是中断会导致 <strong>pc</strong> 设置为 BASE 对应的地址加上 4 倍中断原因 ID(interrupt cause number)</li></ul><h3 id="Machine-Trap-Delegation-Register-medeleg-and-mideleg"><a href="#Machine-Trap-Delegation-Register-medeleg-and-mideleg" class="headerlink" title="Machine Trap Delegation Register (medeleg and mideleg)"></a>Machine Trap Delegation Register (<code>medeleg</code> and <code>mideleg</code>)</h3><p>默认在所有特权级的所有陷入都是在机器模式下处理的，尽管一个机器模式 handler 能够使用 MRET 指令将陷入重定向回适合的等级。陷入不会从高等级向低等级委托。</p><p>为了提升性能，实现能够在 <code>medeleg</code> 和 <code>mideleg</code> 中提供单个 read&#x2F;write 位，标识特定的异常和中断需要在一个更低的特权级处理。machine exception delegation register (medeleg) 和 machine interrupt delegation register (mideleg) 都是 MXLEN 位的可读写寄存器。</p><p>在有 S-mode 的实现里，在 <code>medeleg</code> 和 <code>mideleg</code> 中的位会将 S-mode 或者 U-mode 里的陷入操作，委托到 S-mode 做陷入处理。假如没有 S-mode，这两个寄存器都不应该存在。</p><p>在陷入被委托到 S-mode 里时：</p><ul><li>将陷入的原因写到 <code>scause</code> 寄存器里；</li><li>将发生陷入的虚拟地址写到 <code>spec</code> 寄存器里</li><li>将异常特定值写到 <code>stval</code> 寄存器里</li><li>将发生陷入时特权模式写到 <code>mstatus</code> 里的 SPP 域</li><li>将发生陷入时的 SIE 域的值写到 <code>mstatus</code> 里的 SPIE 域</li><li>清除 <code>mstatus</code> 的 SIE 域</li></ul><h3 id="Machine-Interrupt-Registers-mip-and-mie"><a href="#Machine-Interrupt-Registers-mip-and-mie" class="headerlink" title="Machine Interrupt Registers (mip and mie)"></a>Machine Interrupt Registers (<code>mip</code> and <code>mie</code>)</h3><p><code>mip</code> 寄存器是一个 MXLEN 宽的可读写寄存器，包括了被阻塞的中断。<code>mie</code> 寄存器则是一个 MXLEN 宽的可读写寄存器，包括了启用的中断。</p><p>一个中断 $i$ 会陷入到 M-mode，需要满足下列条件：</p><ul><li>要么当前的特权级是 M 并且 <code>mstatus</code> 里的 MIE 位被设置了，要么当前的特权级比 M-mode 要低</li><li><code>mie</code> 和 <code>mip</code> 里的 $i$ 位被设置了。</li><li>如果 <code>mideleg</code> 存在，$i$ 位没有在 <code>mideleg</code> 里设置。</li></ul><p>在中断发生时，这些条件应该在有限时间内判断完成，<code>mip</code> 的阻塞，在 xRET 指令的执行之后，或者对这些条件依赖的 CSR 的显式写入</p><p><img src="/source/images/Machine%20Interrrupt%20Registers.png" alt="Machine Interrupt Registers (mip and mie)"></p><ul><li><code>mip.MEIP</code> 和 <code>mie.MEIE</code> 负责 machine-level 的外部中断</li><li><code>mip.MTIP</code> 和 <code>mie.MTIP</code> 负责 machine-level 的计时器中断</li><li><code>mip.MSIP</code> 和 <code>mie.MSIE</code> 负责 machine-level 的软件中断</li><li><code>mip.SEIP</code> 和 <code>mie.SEIE</code> 负责 supervisor-level 的外部中断</li><li><code>mip.STIP</code> 和 <code>mie.STIP</code> 负责 supervisor-level 的计时器中断</li><li><code>mip.SSIP</code> 和 <code>mie.SSIE</code> 负责 supervisor-level 的软件中断</li></ul><h3 id="Hardware-Performance-Monitor"><a href="#Hardware-Performance-Monitor" class="headerlink" title="Hardware Performance Monitor"></a>Hardware Performance Monitor</h3><ul><li><code>mcycle</code> CSR 记录硬件线程在该处理器核上运行的时钟周期</li><li><code>minstret</code> CSR 记录硬件线程已经完成的指令数量</li></ul><p>此外，硬件性能监视器提供了 29 个附加的 64 位时间计数器：<code>mhpmcounter3</code>-<code>mhpmcounter31</code></p><p>时间选择器 event selector CSRs <code>mhpmevent3-mhpmevent31</code> 时 MXLEN 位的 WARL 寄存器，指定造成相应计数器增加的事件。</p><h3 id="Machine-Counter-Enable-Register-mcounteren"><a href="#Machine-Counter-Enable-Register-mcounteren" class="headerlink" title="Machine Counter-Enable Register (mcounteren)"></a>Machine Counter-Enable Register (<code>mcounteren</code>)</h3><p><code>mcounteren</code> 是一个 32 位寄存器，控制硬件性能监视器-计数器对应低一级特权级可以访问。</p><h3 id="Machine-Counter-Inhibit-CSR-mcountinhibit"><a href="#Machine-Counter-Inhibit-CSR-mcountinhibit" class="headerlink" title="Machine Counter-Inhibit CSR (mcountinhibit)"></a>Machine Counter-Inhibit CSR (<code>mcountinhibit</code>)</h3><p><code>mcountinhibit</code> 是一个 32 位寄存器，控制哪些硬件性能监视器-计数器可以增加。</p><h3 id="Machine-Scratch-Register-mscratch"><a href="#Machine-Scratch-Register-mscratch" class="headerlink" title="Machine Scratch Register (mscratch)"></a>Machine Scratch Register (<code>mscratch</code>)</h3><p><code>mscratch</code> 寄存器是一个 MXLEN 位宽的可读写寄存器，只在 machine mode 下使用。它保存一个指针指向 M-mode 硬件线程本地的上下文空间，在 M-mode 陷入处理时和用户寄存器交换。</p><h3 id="Machine-Exception-Program-Counter-mepc"><a href="#Machine-Exception-Program-Counter-mepc" class="headerlink" title="Machine Exception Program Counter (mepc)"></a>Machine Exception Program Counter (<code>mepc</code>)</h3><p><code>mepc</code> 寄存器是一个 MXLEN 位宽的可读写寄存器。<code>mepc[0]</code> 一直是 0.<br>该寄存器必须保存有效的虚拟地址。在 M-mode 处理陷入是，<code>mepc</code> 写入发生中断&#x2F;异常的指令虚拟地址。</p><h3 id="Machine-Cause-Register-mcause"><a href="#Machine-Cause-Register-mcause" class="headerlink" title="Machine Cause Register (mcause)"></a>Machine Cause Register (<code>mcause</code>)</h3><p><code>mcause</code> 寄存器是一个 MXLEN 位宽的可读写寄存器。当 M-mode 处理陷入时，<code>mcause</code> 写入造成陷入的事件的 ID。</p><h3 id="Machine-Trap-Value-Register-mtval"><a href="#Machine-Trap-Value-Register-mtval" class="headerlink" title="Machine Trap Value Register (mtval)"></a>Machine Trap Value Register (<code>mtval</code>)</h3><p><code>mtval</code> 寄存器是一个 MXLEN 位宽的可读写寄存器。当 M-mode 处理陷入时，<code>mtval</code> 要么写入 0，要么写入异常信息来辅助处理陷入。</p><h3 id="Machine-Configuration-Pointer-Register-mconfigptr"><a href="#Machine-Configuration-Pointer-Register-mconfigptr" class="headerlink" title="Machine Configuration Pointer Register (mconfigptr)"></a>Machine Configuration Pointer Register (<code>mconfigptr</code>)</h3><p><code>mconfigptr</code> 寄存器是一个 MXLEN 位宽的只读寄存器。保存配置数据结构的物理地址。</p><h3 id="Machine-Environment-Configuration-Registers-menvcfg-and-menvcfgh"><a href="#Machine-Environment-Configuration-Registers-menvcfg-and-menvcfgh" class="headerlink" title="Machine Environment Configuration Registers (menvcfg and menvcfgh)"></a>Machine Environment Configuration Registers (<code>menvcfg</code> and <code>menvcfgh</code>)</h3><p><code>menvcfg</code> 寄存器是一个 MXLEN 位宽的可读写寄存器。控制比 M 更低特权级下的执行环境。</p><h3 id="Machine-Security-Configuration-Register-mseccfg"><a href="#Machine-Security-Configuration-Register-mseccfg" class="headerlink" title="Machine Security Configuration Register (mseccfg)"></a>Machine Security Configuration Register (<code>mseccfg</code>)</h3><p><code>mseccfg</code> 寄存器是一个可选的 MXLEN 位宽的可读写寄存器。控制安全特征。</p><h2 id="Machine-Level-Memory-Mapped-Registers"><a href="#Machine-Level-Memory-Mapped-Registers" class="headerlink" title="Machine-Level Memory-Mapped Registers"></a>Machine-Level Memory-Mapped Registers</h2><h3 id="Machine-Timer-Registers-mtime-and-mtimecmp"><a href="#Machine-Timer-Registers-mtime-and-mtimecmp" class="headerlink" title="Machine Timer Registers (mtime and mtimecmp)"></a>Machine Timer Registers (<code>mtime</code> and <code>mtimecmp</code>)</h3><p><code>mtime</code> 提供真实时间的计数器，作为一个 memory-mapped M-mode 可读写寄存器。<br>其按照固定频率增加。</p><p><code>mtimecmp</code> 寄存器。在其值大于 <code>mtime</code> 时，会发出时钟中断。当然要求开中断和 <code>mie</code>寄存器中<code>MTIE</code>位的设置。</p><h2 id="Machine-Mode-Privileged-Instructions"><a href="#Machine-Mode-Privileged-Instructions" class="headerlink" title="Machine-Mode Privileged Instructions"></a>Machine-Mode Privileged Instructions</h2><h3 id="Environment-Call-and-Breakpoint"><a href="#Environment-Call-and-Breakpoint" class="headerlink" title="Environment Call and Breakpoint"></a>Environment Call and Breakpoint</h3><p><strong>ECALL</strong> 指令用来发送请求给支持执行环境。<br>在 U-mode、S-mode 或者 M-mode 下执行该指令时，它生成一个 environment-call-from-U-mode exception, environment-call-from-S-mode exception 或者 environment-call-from-M-mode exception。</p><p><strong>EBREAK</strong> 指令被调试器用来使得控制信号传输到调试环境。它产生一个断点异常。</p><p>这两个指令都会使得接收特权模式的 <code>epc</code> 寄存器设置成 ECALL 或者 EBREAK 的指令地址。它们不会使得 <code>minstret</code> CSR 增加。</p><h3 id="Trap-Return-Instruction"><a href="#Trap-Return-Instruction" class="headerlink" title="Trap-Return Instruction"></a>Trap-Return Instruction</h3><p><code>MRET</code>&#x2F;<code>SRET</code> 用来在处理陷入后返回，对应不同的特权级。可以在执行一个比当前特权级更低的返回指令，其会弹出相应的低特权级中断和特权模式栈。此外，它还将 pc 设置位 <code>epc</code> 寄存器里的值</p><h3 id="Wait-for-Interrupt"><a href="#Wait-for-Interrupt" class="headerlink" title="Wait for Interrupt"></a>Wait for Interrupt</h3><p><code>WFI</code> 指令默认当权硬件线程能够被暂停直到一个需要被处理的中断发生。<code>WFI</code> 指令也能够用来通知硬件平台合适的中断需要在该硬件线程上优先处理。<br>该指令能够在任何特权级下使用。</p><h2 id="Non-Maskable-Interrupts"><a href="#Non-Maskable-Interrupts" class="headerlink" title="Non-Maskable Interrupts"></a>Non-Maskable Interrupts</h2><p><strong>Non-maskable interrupts (NMIs)</strong> 只能够用做硬件错误条件，使处理器立即跳转到 M-mode 下定义的 NMI 向量，无论是否有硬件中断使能。<code>mepc</code> 寄存器存储被中断的指令地址，<code>mcause</code> 存储造成 NMI 的原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;机器模式 Machine Level 在 RISC-V 系统中是最高特权级。M-mode 用来提供低等级的，对硬件的操作。系统的最初状态就是机器模式。&lt;/p&gt;
&lt;h2 id=&quot;Machine-Level-CSRs&quot;&gt;&lt;a href=&quot;#Machine-Level-CSRs&quot;</summary>
      
    
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/categories/RISC-V/"/>
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/tags/RISC-V/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/tags/Hardware/"/>
    
    <category term="Privileged mode" scheme="http://bl-gs.github.io/tags/Privileged-mode/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V CSR Introduction</title>
    <link href="http://bl-gs.github.io/2023/08/25/RISCV-CSR/"/>
    <id>http://bl-gs.github.io/2023/08/25/RISCV-CSR/</id>
    <published>2023-08-25T06:30:06.391Z</published>
    <updated>2023-08-25T07:33:09.462Z</updated>
    
    <content type="html"><![CDATA[<p>RISC-V ISA 中，SYSTEM 类 opcode 被用来编码所有的特权指令。这些指令主要可以分为两类：<br>在 Zicsr 扩展中定义的原子 read-modify-write <strong>Control and Status Registers (CSRs)</strong> 和其他特权指令。</p><p>CSR 寄存器仅允许对应特权级或者更高特权级下的访问。对于标准的 CSR 寄存器，读不会产生副作用，但是写会产生副作用。</p><h2 id="CSR-地址映射规则"><a href="#CSR-地址映射规则" class="headerlink" title="CSR 地址映射规则"></a>CSR 地址映射规则</h2><p>标准 RISC-V ISA 预留 12 位编码空间 <code>csr[11:0]</code> 可以支持多达 4096 个 CSRs。一般来说：</p><ul><li><code>csr[11:8]</code> 用来指示特定特权级下 <strong>CSRs 是否可读或者可写</strong></li><li><code>csr[11:10]</code> 用来只是寄存器是否是只读(11) 或者可读写的(00, 01, 10)</li><li><code>csr[9:8]</code> 用来指示访问该寄存器的最低特权级</li><li>M mode 下标准读写 CSRs 0x7A0-0x7BF 是保留给调试用的。其中 0x7A0-0x7AF 可以在 M mode 下访问，但是 0x7B0-0x7BF 只对 debug mode 可见。</li></ul><blockquote><p><strong>Exception</strong><br>尝试访问不存在的 CSR 会导致 <em>illegal instruction exception</em>。<br>尝试在不当的特权级下访问 CSR 或者写一个只读寄存器会导致 <em>illegal instruction exception</em>。<br>M mode 下访问 0x7B0-0x7BF 的 CSRs 应该导致 <em>illegal instruction exception</em><br>一些可读写寄存器可能包含若干个只读位，对这些位的写入会被忽略</p></blockquote><h2 id="CSR-Field-规范"><a href="#CSR-Field-规范" class="headerlink" title="CSR Field 规范"></a>CSR Field 规范</h2><p><strong>Reserved Writes Preserve Valuds, Reads Ignore Values (WPRI)</strong></p><p>这些是一些预留的可读&#x2F;写寄存器。软件可以忽略它的值，在写其他 fields 时也需要保留这些 field 的值，将其赋值为只读的全 0，以实现向前兼容。</p><p><strong>Write&#x2F;Read Only Legal Values (WLRL)</strong></p><p>这些 read&#x2F;write CSRs 只对一个编码子集做了行为规定，其他的编码功能保留。软件也不应该写入未定义的编码，同时不该假定读取的值都是合法的。或者寄存器在另一套操作集合后是否被写入。</p><p>当一个指令尝试为其赋值一个未定义值，可以但不要求引出 <em>illegal instruction exception</em>。在写入非法值之后，读取结果是未定义的，但是应该取决于这次写入或者之前的合法写入。</p><p><strong>Write Any Values, Reads Legal Values (WARL)</strong></p><p>这些 read&#x2F;write CSRs 只对一个编码子集做了行为规定，其他的编码功能保留，但是能够保证所有读取的值都是合法的。</p><p>假设写入的 CSR 没有其他副作用，可以通过写入值，然后读出判断是否相同，从而得到是否支持该值。</p><p>写入未定义值时，不会导致异常，但是在读的时候，只会返回最后一次写入的合法值，取决于这次写入或者之前的合法写入。</p><h2 id="CSR-Field-调整"><a href="#CSR-Field-调整" class="headerlink" title="CSR Field 调整"></a>CSR Field 调整</h2><p>如果对 CSRs 的写入改变了其他 CSR 的合法值，那么除非特殊定义，这个 CSR field 就会立即从一个新的合法值得到一个 UNSPECIFIED 值。</p><h2 id="Implicit-Reads-of-CSRs"><a href="#Implicit-Reads-of-CSRs" class="headerlink" title="Implicit Reads of CSRs"></a>Implicit Reads of CSRs</h2><p>在实现中，可能需要隐式地读取 CSR 的值，这个时候，除非特殊规定，这个值应该和合法显式读取的结果相同。</p><h2 id="CSR-宽度调整"><a href="#CSR-宽度调整" class="headerlink" title="CSR 宽度调整"></a>CSR 宽度调整</h2><p>假如 CSR 的宽度是可变的，可写 field 的值和宽度改变后的 CSR，除非特殊定义，取决于之前 CSR 的值：</p><ul><li>previous-width CSR 复制到一个相同宽度的临时寄存器里</li><li>对于 previous-width 中的只读域，临时寄存器里的相同位置被设置为 0</li><li>临时寄存器的宽度变为新的宽度：假如变小了，不重要的 W bits 被保留，重要的 bits 被丢弃；假如变宽了，临时寄存器做 0 扩展</li><li>new-width CSR 的每个可写域得到临时寄存器里的相应值</li></ul><p>由于改变宽度不是对 CSR 的读写，因此不产生副作用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RISC-V ISA 中，SYSTEM 类 opcode 被用来编码所有的特权指令。这些指令主要可以分为两类：&lt;br&gt;在 Zicsr 扩展中定义的原子 read-modify-write &lt;strong&gt;Control and Status Registers (CSRs)</summary>
      
    
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/categories/RISC-V/"/>
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/tags/RISC-V/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/tags/Hardware/"/>
    
    <category term="Privileged mode" scheme="http://bl-gs.github.io/tags/Privileged-mode/"/>
    
  </entry>
  
  <entry>
    <title>Makefile</title>
    <link href="http://bl-gs.github.io/2023/08/24/Makefile%20Tutorial/"/>
    <id>http://bl-gs.github.io/2023/08/24/Makefile%20Tutorial/</id>
    <published>2023-08-24T11:31:37.786Z</published>
    <updated>2023-08-24T14:19:01.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile-介绍"><a href="#Makefile-介绍" class="headerlink" title="Makefile 介绍"></a>Makefile 介绍</h2><p><code>make</code> 命令执行时，需要当前目录下有一个 <strong>Makefile</strong> 文件，以便其执行其中指定的步骤。若使用别的文件名来写 Makefile，则需要用 <code>-f</code> 或者 <code>--file</code> 指定文件。</p><p>编写 Makefile 的原则应该是只编译被修改过的文件，不重复编译，最后将所有编译输出链接从而生成可执行文件。虽然经常举 C 语言编译链接为例，但是由于 Unix Makefile 和 Unix&#x2F;Linux 是紧密结合的，可以将其视作特殊规则的 shell 脚本，其中执行的命令主要是 shell 命令。</p><h2 id="Makefile-语法规则"><a href="#Makefile-语法规则" class="headerlink" title="Makefile 语法规则"></a>Makefile 语法规则</h2><pre><code class="Makefile">target: prerequisitescommand</code></pre><ul><li><strong>target</strong> 也就是一个目标文件，可以是目标文件，也可以是执行文件。还可以是一个标签(Label)。</li><li><strong>prerequisites</strong> 就是，要生成那个 target 所需要的文件或是目标。</li><li><strong>command</strong> 也就是make需要执行的命令。（任意的 shell 命令）</li></ul><p>这是主要的编写逻辑，如</p><pre><code class="Makefile">CC=gccALL: hello.o    CC -o hello hello.ohello.o: hello.c    CC -c hello.cclean:     rm hello hello.o</code></pre><p>中规定了 <em>ALL</em> 目标依赖于 <em>hello.o</em>，同时 <em>hello.o</em> 又依赖于 <em>hello.c</em>，即我们的源文件，从而，当我们执行 <code>make</code> 或者 <code>make all</code> 时，会编译输出 hello 可执行文件。</p><p>需要注意的是，在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，<strong>一定要以一个 Tab 键作为开头</strong>。Tab 键并不能被随意使用。</p><h3 id="Makefile-工作方式"><a href="#Makefile-工作方式" class="headerlink" title="Makefile 工作方式"></a>Makefile 工作方式</h3><p>假设当前目录下有上述的 Makefile 文件和源文件 hello.c。</p><ul><li><code>make</code> 会在当前目录下寻找名字为 “Makefile” 或者 “makefile” 的文件。</li><li>读入被 include 的其他文件</li><li>初始化文件中变量</li><li>找到后，会找到文件中的第一个 target，上述例子中为 <code>ALL</code>，为一个标签，将其作为最终的目标</li><li>分析依赖关系，建立依赖关系链</li><li>根据其依赖关系，他会寻找 hello.o 目标文件，若 hello.o 不存在，或是其依赖的后面的源文件修改时间比 hello.o 要新，则执行相应的命令</li><li>依次遍历，得到需要执行的拓扑顺序后，执行相应指令。</li></ul><p>需要注意的是，make 只关注文件依赖关系的错误，而不管命令执行中的错误。只要依赖关系正常满足，照样能够完成。</p><h3 id="Makefile-变量"><a href="#Makefile-变量" class="headerlink" title="Makefile 变量"></a>Makefile 变量</h3><p>在 Makefile 中使用变量如：</p><pre><code class="Makefile">object = hello.o bye.o</code></pre><p>之后，就能够通过 <code>$(object)</code> 引用该变量</p><h3 id="Makefile-自动推导"><a href="#Makefile-自动推导" class="headerlink" title="Makefile 自动推导"></a>Makefile 自动推导</h3><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令</p><p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了：</p><pre><code class="Makefile">CC=gccALL:hello.o    gcc -o hello hello.ohello.o: clean:    rm hello hello.o</code></pre><h3 id="清空目标文件"><a href="#清空目标文件" class="headerlink" title="清空目标文件"></a>清空目标文件</h3><p>一般风格是：</p><pre><code class="Makefile">clean:     rm hello $(objects)</code></pre><p>更为稳健的风格是：</p><pre><code class="Makefile">.PHONY: cleanclean:     -rm hello $(objects)</code></pre><p><strong>.PHONY</strong> 意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。不成文的规矩是——“clean从来都是放在文件的最后”。</p><h3 id="引入其他文件"><a href="#引入其他文件" class="headerlink" title="引入其他文件"></a>引入其他文件</h3><p>通过 <code>include</code> 可以将其他文件引入当前文件中，类似于 C 语言头文件的直接复制。</p><pre><code class="Makefile">include &lt;filename&gt;</code></pre><p>除此之外，可以引入多个文件（用空格隔开），或者使用类似于 shell 的通配符</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>make 和 Unix shell 相同，支持若干种通配符：<code>*</code>、<code>?</code>、<code>[...]</code>，</p><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>由于目标假如是标签，它不能和文件名重名，不然会被依赖关系监测到并假如依赖链。<br>因此通过 <code>.PHONY</code> 指明其为伪目标，不管是否有这个文件，都会执行这个目标。</p><h3 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h3><p>可能有多个目标同时依赖于同一个文件</p><pre><code class="Makefile">bigoutput littleoutput : text.g    generate text.g -$(subst output,,$@) &gt; $@</code></pre><p>等价于</p><pre><code class="Makefile">bigoutput : text.g    generate text.g -big &gt; bigoutputlittleoutput : text.g    generate text.g -little &gt; littleoutput</code></pre><h3 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h3><p>静态模式可以更加容易地定义多目标的规则，语法如下：</p><pre><code class="Makefile">&lt;targets...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;　　　&lt;commands&gt;</code></pre><p>其中：</p><ul><li><strong>targets</strong> 定义了一系列的目标文件，可以有通配符。是目标的一个集合。</li><li><strong>target-parrtern</strong> 是指明了targets的模式，也就是的目标集模式。</li><li><strong>prereq-parrterns</strong> 是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</li></ul><pre><code class="Makefile">objects = foo.o bar.oall: $(objects)$(objects): %.o: %.c    $(CC) -c $(CFLAGS) $&lt; -o $@</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>用变量定义变量，并不要求右值变量已经被定义，即可以推迟赋值</p><pre><code class="Makefile">foo=$(bar)bar=$(ugh)ugh=Huh</code></pre><p>这里 foo, bar, ugh 都是 Huh。但是这种定义也容易造成无限递归定义。<br>因此可以使用 <code>:=</code> 操作符，但是前面的变量就不能使用后来的变量了</p><pre><code class="Makefile">x := fooy := $(x) barx := later</code></pre><p>这里 y 为 foo bar</p><p>还有个 <code>?=</code> 操作符，如 <code>FOO ?= bar</code><br>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做</p><h3 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h3><p>我们可以替换变量中的共有的部分，其格式是 <code>$(var:a=b)</code> 或是 <code>$&#123;var:a=b&#125;</code>，其意思是，把变量 var 中所有以 a 字串结尾的 <code>a</code> 替换成 <code>b</code> 字串。这里的结尾意思是空格或是结束符。如：</p><pre><code class="Makefile">foo := a.o b.o c.obar := $(foo:.o=.c)</code></pre><p>bar 即为 a.c b.c c.c</p><p>当然也可以使用静态模式替换变量，如：</p><pre><code class="Makefile">foo := a.o b.o c.obar := $(foo:%.o=%.c)</code></pre><h3 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h3><p>我们可以使用“+&#x3D;”操作符给变量追加值，如：</p><pre><code class="Makefile">objects = main.o objects += another.o</code></pre><p>则 objects 为 main.o another.o</p><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p><pre><code class="Makefile">override &lt;variable&gt; = &lt;value&gt;override &lt;variable&gt; := &lt;value&gt;</code></pre><h3 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h3><p>为特定目标设置私有的变量值</p><pre><code class="Makefile">&lt;target ...&gt; : &lt;variable-assignment&gt;&lt;target ...&gt; : overide &lt;variable-assignment&gt;</code></pre><p>如：</p><pre><code class="Makefile">prog : CFLAGS = -gprog : prog.o foo.o bar.o    $(CC) $(CFLAGS) prog.o foo.o bar.o</code></pre><p>这样，无论外部如何，prog 目标中，CFLAGS 一直是 -g</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code>、<code>else</code>、<code>endif</code></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：</p><pre><code class="Makefile">$(&lt;function&gt; &lt;arguments&gt;)$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</code></pre><p>这里，<code>&lt;function&gt;</code> 就是函数名，make支持的函数不多。<code>&lt;arguments&gt;</code> 是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。</p><h3 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h3><p><code>$@</code><br>表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合。</p><p><code>$%</code><br>仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，<code>$%</code> 就是”bar.o”，<code>$@</code> 就是”foo.a”。如果目标不是函数库文件（Unix下是<br>[.a]，Windows下是[.lib]），那么，其值为空。</p><p><code>$&lt;</code><br>依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么<code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p><p><code>$?</code><br>所有比目标新的依赖目标的集合。以空格分隔。</p><p><code>$^</code><br>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p><p><code>$+</code><br>这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p><p><code>$*</code><br>这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir&#x2F;a.foo.b”，并且目标的模式是”a.%.b”，那么，<code>$*</code>的值就是”dir &#x2F;a.foo”。这个变量对于构造有关联的文件名是比<br>较有较。如果目标中没有模式的定义，那么<code>$*</code>也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么<code>$*</code>就是除了后缀的那一部分。例如：如果目标是”foo.c”<br>，因为”.c”是make所能识别的后缀名，所以，<code>$*</code>的值就是”foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用<code>$*</code>，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么<code>$*</code>就是空值。</p><p>当你希望只对更新过的依赖文件进行操作时，<code>$?</code>在显式规则中很有用，例如，假设有一个函数库文件叫”lib”，其由其它几个object文件更新。那么把object文件打包的比较有效<br>率的Makefile规则是：</p><pre><code class="Makefile">lib : foo.o bar.o lose.o win.oar r lib $?</code></pre><p>在上述所列出来的自动量变量中。四个变量（<code>$@、$&lt;、$%、$*</code>）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上”D”或”F”字样。这是GNU make中老版本的特性，在新版本中，我们使用函数”dir”或”notdir”就可以做到了。”D”的含义就是Directory，就是目录，”F”的含义就是File，就是文件。</p><p>下面是对于上面的七个变量分别加上”D”或是”F”的含义：</p><p><code>$(@D)</code><br>表示<code>$@</code>的目录部分（不以斜杠作为结尾），如果<code>$@</code>值是”dir&#x2F;foo.o”，那么<code>$(@D)</code>就是”dir”，而如果<code>$@</code>中没有包含斜杠的话，其值就是”.”（当前目录）。</p><p><code>$(@F)</code><br>表示<code>$@</code>的文件部分，如果<code>$@</code>值是”dir&#x2F;foo.o”，那么<code>$(@F)</code>就是”foo.o”，<code>$(@F)</code>相当于函数<code>$(notdir $@)</code>。</p><p><code>$(*D)</code><br><code>$(*F)</code><br>和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>$(*D)</code>返回”dir”，而<code>$(*F)</code>返回”foo”</p><p><code>$(%D)</code><br><code>$(%F)</code><br>分别表示了函数包文件成员的目录部分和文件部分。这对于形同”archive(member)”形式的目标中的”member”中包含了不同的目录很有用。</p><p><code>$(&lt;D)</code><br><code>$(&lt;F)</code><br>分别表示依赖文件的目录部分和文件部分。</p><p><code>$(^D)</code><br><code>$(^F)</code><br>分别表示所有依赖文件的目录部分和文件部分。（无相同的）</p><p><code>$(+D)</code><br><code>$(+F)</code><br>分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</p><p><code>$(?D)</code><br><code>$(?F)</code><br>分别表示被更新的依赖文件的目录部分和文件部分。</p><p>最后想提醒一下的是，对于<code>$&lt;</code>，为了避免产生不必要的麻烦，我们最好给<code>$</code>后面的那个特定字符都加上圆括号，比如，<code>$(&lt; )</code>就要比<code>$&lt;</code>要好一些。</p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h3><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p><p>Makefile文件中的特殊变量 <strong>VPATH</strong> 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p><pre><code class="Makefile">VPATH = src:include</code></pre><p>上面的定义指定了两个目录，make 会按照该顺序进行搜索，文件目录用冒号风格</p><p>另一个是搜索文件的方式是通过 <code>vpath</code> 关键字：</p><ul><li><code>vpath &lt;pattern&gt; &lt;directories&gt;</code> 为符合模式的文件指定搜索目录</li><li><code>vpath &lt;pattern&gt;</code> 清除符合该模式的文件搜索目录</li><li><code>vpath</code> 清除所有已经设置的文件搜索目录</li></ul><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改 Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用 C&#x2F;C++ 编译的一个功能。大多数的 C&#x2F;C++ 编译器都支持一个 <code>-M</code> 的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令</p><p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要注意的是，如果你使用 GNU 的 C&#x2F;C++ 编译器，你得用 <code>-MM</code> 参数，不然，<code>-M</code> 参数会把一些标准库的头文件也包含进来。</p><p>GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p><pre><code class="Makefile">%.d: %.c    @set -e; rm -f $@; \    $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.; \    sed &#39;s,    \.o[ :]*,\1.o $@ : ,g&#39; &lt; $@. &gt; $@; \    rm -f $@.</code></pre><p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm-f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，“”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p><h3 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h3><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 <code>@</code> 字符在命令行前，那么，这个命令将不被make显示出来</p><h3 id="嵌套执行"><a href="#嵌套执行" class="headerlink" title="嵌套执行"></a>嵌套执行</h3><p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：<br><code>export&lt;variable ...&gt;</code></p><p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：<br><code>unexport&lt;variable ...&gt;</code></p><p>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束</p><pre><code class="Makefile">define run-yaccyacc $(firstword $^)mv y.tab.c $@endef</code></pre><h3 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h3><p>make 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p><h3 id="退出码"><a href="#退出码" class="headerlink" title="退出码"></a>退出码</h3><ul><li>0 —— 表示成功执行。</li><li>1 —— 如果make运行时出现任何错误，其返回1。</li><li>2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Makefile-介绍&quot;&gt;&lt;a href=&quot;#Makefile-介绍&quot; class=&quot;headerlink&quot; title=&quot;Makefile 介绍&quot;&gt;&lt;/a&gt;Makefile 介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;make&lt;/code&gt; 命令执行时，需要当前目录下有一个</summary>
      
    
    
    
    <category term="Language" scheme="http://bl-gs.github.io/categories/Language/"/>
    
    
    <category term="Tool" scheme="http://bl-gs.github.io/tags/Tool/"/>
    
    <category term="Language" scheme="http://bl-gs.github.io/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>RISC-V Privileged Architecture</title>
    <link href="http://bl-gs.github.io/2023/08/19/RISC-V%20PMP/"/>
    <id>http://bl-gs.github.io/2023/08/19/RISC-V%20PMP/</id>
    <published>2023-08-19T12:16:30.330Z</published>
    <updated>2023-08-19T12:56:51.769Z</updated>
    
    <content type="html"><![CDATA[<p>RISC-V 规定了四种权限模式：</p><ul><li>00: <strong>M (Machine mode)</strong></li><li>10: <strong>Reserve</strong></li><li>01: <strong>S (Superior mode)</strong></li><li>11: <strong>U (User mode)</strong></li></ul><h2 id="Machine-Mode"><a href="#Machine-Mode" class="headerlink" title="Machine Mode"></a>Machine Mode</h2><p>机器模式是 RISC-V 中 <strong>hart（hardware thread 硬件线程）</strong>可以执行的最高权限等级。该模式下，hart 对内存、I&#x2F;O 等具有完全的使用权限。</p><h3 id="Interrupt-Exception"><a href="#Interrupt-Exception" class="headerlink" title="Interrupt &amp; Exception"></a>Interrupt &amp; Exception</h3><p>中断的来源有：<strong>软件中断、时钟中断、外部中断</strong>。</p><ul><li>软件中断通过向内存映射寄存器中存数来触发，并通常用于由一个 hart 中断另一个 hart（在其他架构中称为处理器间中断机制）。</li><li>时钟中断：当实时计数器 mtime 大于 hart 的时间比较器（一个名为 mtimecmp 的内存映射寄存器）时，会触发。RISC-V 规定，在机器模式下，只有当 mtimecmp 寄存器被重新写入后，mip 寄存器中的时钟中断标志位才会被清除。因此，每次处理时钟中断，都不能忘记更新 mtimecmp 。</li><li>外部中断由平台级中断控制器（大多数外部设备连接到这个中断控制器）引发。不同的硬件平台具有不同的内存映射并且需要中断控制器的不同特性，因此用于发出和消除这些中断的机制因平台而异。</li></ul><p>当发生中断嵌套时，会转到更高优先级的中断</p><h3 id="CSR-Register"><a href="#CSR-Register" class="headerlink" title="CSR Register"></a>CSR Register</h3><ul><li><strong>mstatus</strong>：包含了中断使能、中断类型、特权级别等</li><li><strong>mip</strong>：指示了何种类型的中断正在传入(pending)</li><li><strong>mie</strong>：包含了相应的中断使能位</li><li><strong>mcause</strong>：记录中断&#x2F;异常事件的类型&#x2F;起因，异常之间还有优先级之分</li><li><strong>mtvec</strong>：存放了 trap vector 的信息，包括了基地址喝模式</li></ul><h3 id="Phsical-Memory-Protection-PMP"><a href="#Phsical-Memory-Protection-PMP" class="headerlink" title="Phsical Memory Protection, PMP"></a>Phsical Memory Protection, PMP</h3><p>在硬件设计里，PMP 是可选项，但在大部分地方我们都可以见到它的身影。PMP 检查一般用于 hart 在监管者模式或用户模式下的所有访问；或者在 mstatus.MPRV &#x3D; 1 时的 load 和 store 等情况。一旦触发 PMP 保护，RISC-V 要求产生精确中断并处理。</p><p>PMP 允许机器模式指定用户模式下可以访问的内存地址。PMP entry 由一个 8-bit 的 PMP 配置寄存器和一个 32&#x2F;64 位长的 PMP 地址寄存器组成。整个 PMP 包括若干个（通常为 8 到 16 组）PMP entry 。配置寄存器可以配置读、写和执行权限，地址寄存器用来划定界限。</p><p>当处于用户模式的处理器尝试 load 或 store 操作时，将地址和所有的 PMP 地址寄存器比较。如果地址大于等于 PMP 地址 i，但小于 PMP 地址 i+1，则 PMP i+1 的配置寄存器决定该访问是否可以继续，如果不能将会引发访问异常。</p><h2 id="Superior-Mode"><a href="#Superior-Mode" class="headerlink" title="Superior Mode"></a>Superior Mode</h2><p>前文所述，mstatus 、mie 、mip 、mtvec 等寄存器在监管者模式下都有与之名字几乎一样的、功能也相似的寄存器。</p><p>相比于机器模式的最高权限和强制手段，监管者模式没有这么高的权限。一般来说，监管者模式就是为对标现代操作系统而生的。监管者模式通常存在于复杂的 RISC-V 系统上，其核心功能就是支持内存分页、内存保护、中断&#x2F;异常处理等。当然，监管者模式还是有些地方与机器模式不同，接下来我会重点介绍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RISC-V 规定了四种权限模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;00: &lt;strong&gt;M (Machine mode)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;10: &lt;strong&gt;Reserve&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;01: &lt;strong&gt;S (Superi</summary>
      
    
    
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/categories/RISC-V/"/>
    
    
    <category term="Virtualization" scheme="http://bl-gs.github.io/tags/Virtualization/"/>
    
    <category term="RISC-V" scheme="http://bl-gs.github.io/tags/RISC-V/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://bl-gs.github.io/2023/08/16/MemVirtualization/"/>
    <id>http://bl-gs.github.io/2023/08/16/MemVirtualization/</id>
    <published>2023-08-16T13:32:44.526Z</published>
    <updated>2023-08-16T13:32:44.526Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>CPU Virtualization</title>
    <link href="http://bl-gs.github.io/2023/08/16/CPUVirtualization/"/>
    <id>http://bl-gs.github.io/2023/08/16/CPUVirtualization/</id>
    <published>2023-08-16T13:32:25.137Z</published>
    <updated>2023-08-16T14:06:42.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intel-VT-x"><a href="#Intel-VT-x" class="headerlink" title="Intel VT-x"></a>Intel VT-x</h2><p>目前，Intel VT技术包含CPU、内存和I／O三方面的虚拟化技术。CPU硬件辅助虚拟化技术，分为对应安腾架构的VT-i(Intel Virtualization Technology for ltanium)和对应x86架构的VT-x(Intel Virtualization Technologyfor x86)两个版本。</p><p>Intel VT-x 提供了两个运行环境：<strong>根环境 root</strong> 和 <strong>非根环境 Non-root</strong>。<br>根环境专门为 VMM 准备，更没有 VT-x 的 X86 差不多，只是多了支持 VT-x 的指令。非根环境则作为一个受限环境用来运行多个虚拟机。</p><p>根操作模式与非根操作模式都有相应的特权级0(Ring 0)至特权级3(Ring 3)。<br>VMM 运行在根模式的特权级 0，guest OS 的内核运行在非根模式的特权级 0，guest OS 的应用程序运行在非根模式的特权级 3。<br>运行环境之间相互转化，从根环境到非根环境叫<strong>VMEntry</strong>；从非根环境到根环境叫<strong>VMExit</strong>。<br>VT-x定义了VMEntry操作，使CPU由根模式切换到非根模式，运行客户机操作系统指令。若在非根模式执行了敏感指令或发生了中断等，会执行VMExit操作，切换回根模式运行VMM。</p><p>VT-x定义了VMEntry操作，使CPU由根模式切换到非根模式，运行客户机操作系统指令。若在非根模式执行了敏感指令或发生了中断等，会执行VMExit操作，切换回根模式运行VMM。</p><p>VMX操作模式流程：</p><ol><li>VMM 执行 VMXON 指令进入 VMX 操作模式。</li><li>VMM 可执行 VMLAUNCH 指令或 VMRESUME 指令产生 VM Entry 操作，进入到 guest OS，此时 CPU 处于非根模式。</li><li>guest OS 执行特权指令等情况导致VMExit的发生，此时将陷入VMM，CPU切换为根模式。VMM 根据 VMExit 的原因作出相应处理，处理完成后将转到步骤 2，继续运行 guest OS。</li><li>VMM可决定是否退出 VMX 操作模式，通过执行 VMXOFF 指令来完成。</li></ol><p>为更好地支持CPU虚拟化，VMX新定义了**虚拟机控制结构 VMCS(Virtual Machine ControlStructure)**。VMCS是保存在内存中的数据结构，其包括虚拟CPU的相关寄存器的内容及相关的控制信息。CPU在发生VM Entry或VMExit时，都会查询和更新VMCS。VMM也可通过指令来配置VMCS，达到对虚拟处理器的管理。</p><p>每个虚拟处理器都需将VMCS与内存中的一块区域联合起来，此区域称为VMCS区域。对VMCS区域的操纵是通过VMCS指针来实现的，这个指针是一个指向VMCS的64位的地址值。VMCS区域是一个最大不超过4KB的内存块，且需4KB对齐。</p><p>VMCS区域分为三个部分：</p><ul><li>偏移0起是 <strong>VMCS 版本标识</strong>，通过不同的版本号，CPU可维护不同的VMCS数据格式；</li><li>偏移4起是 <strong>VMX 中止指示器</strong>，在VMX中止发生时，CPU会在此处存入中止的原因；</li><li>偏移8起是 <strong>VMCS 数据区</strong>，这一部分控制VMX非根操作及VMX切换</li></ul><p>VMCS 的数据区包含了VMX配置信息：VMM在启动虚拟机前配置其哪些操作会触发VMExit。VMExit 产生后，处理器把执行权交给VMM 以完成控制，然后VMM 通过指令触发VMEntry 返回原来的虚拟机或调度到另一个虚拟机。</p><p>VMCS 的数据结构中，每个虚拟机一个，加上虚拟机的各种状态信息，共由3个部分组成，如之前的VMCS架构图所示：</p><ol><li><strong>Gueststate</strong>：该区域保存了虚拟机运行时的状态，在VMEntry 时由处理器装载；在VMExit时由处理器保存。它又由两部分组成：<ol><li>Guest OS寄存器状态。它包括控制寄存器、调试寄存器、段寄存器等各类寄存器的值。</li><li>Guest OS非寄存器状态。用它可以记录当前处理器所处状态，是活跃、停机（HLT）、关机（Shutdown）还是等待启动处理器间中断（Startup-IPI）。</li></ol></li><li><strong>Hoststate</strong>：该区域保存了VMM 运行时的状态，主要是一些寄存器值，在VMExit 时由处理器装载。</li><li><strong>Control data</strong>：该区域包含几部分数据信息，分别是：<ol><li><strong>虚拟机执行控制域</strong>（VM-Execution control fields）。VMM 主要通过配置该区域来控制虚拟机在非根环境中的执行行为。基于针脚的虚拟机执行控制。它决定在发生外部中断或不可屏蔽中断（NMI）要不要发生VMExit。基于处理器的虚拟机执行控制。它决定虚拟机执行RDTSC、HLT、INVLPG 等指令时要不要发生VMExit。</li><li><strong>VMExit 控制域</strong>（VMExit control fields）。该区域控制VMExit 时的行为。当VMExit 发生后处理器是否处于64 位模式；当因为外部中断发生VMExit 时，处理器是否响应中断控制器并且获得中断向量号。VMM 可以用它来定制当VMExit 发生时要保存哪些MSR 并且装载哪些MSR。MSR是CPU的模式寄存器，设置CPU的工作环境和标识cpu的工作状态。</li><li><strong>VMEntry 控制域</strong>（VMEntry control fields）。该区域控制VMEntry 时的行为。它决定处理器VMEntry 后是否处于IA-32e 模式。与VMExit 的MSR控制类似，VMM 用它来定制当VMEntry 发生时要装载哪些MSR。VMM 可以配置VMEntry 时通过虚拟机的IDT向其发送一个事件。在此可以配置将使用IDT 的向量、中断类型（硬件或软件中断）、错误码等。</li><li><strong>VMExit 信息域</strong>（VMExit information fields）。该只读区域包括最近一次发生的VMExit 信息。试图对该区域执行写操作将产生错误。。此处存放VMExit 的原因以及针对不同原因的更多描述信息、中断或异常向量号、中断类型和错误码、通过 IDT 发送事件时产生的VMExit 信息、指令执行时产生的 VMExit 信息。<br>有了VMCS结构后，对虚拟机的控制就是读写VMCS结构。后面对vCPU设置中断，检查状态实际上都是在读写VMCS数据结构。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Intel-VT-x&quot;&gt;&lt;a href=&quot;#Intel-VT-x&quot; class=&quot;headerlink&quot; title=&quot;Intel VT-x&quot;&gt;&lt;/a&gt;Intel VT-x&lt;/h2&gt;&lt;p&gt;目前，Intel VT技术包含CPU、内存和I／O三方面的虚拟化技术。CPU</summary>
      
    
    
    
    <category term="Virtualization" scheme="http://bl-gs.github.io/categories/Virtualization/"/>
    
    <category term="Hardware" scheme="http://bl-gs.github.io/categories/Virtualization/Hardware/"/>
    
    
    <category term="Virtualization" scheme="http://bl-gs.github.io/tags/Virtualization/"/>
    
  </entry>
  
  <entry>
    <title>Virtualization Introduction</title>
    <link href="http://bl-gs.github.io/2023/08/13/Virtualization/"/>
    <id>http://bl-gs.github.io/2023/08/13/Virtualization/</id>
    <published>2023-08-13T14:00:11.686Z</published>
    <updated>2023-08-16T13:19:56.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>虚拟化是将单一物理设备模拟为相互隔离的多个虚拟设备，同时保证这些虚拟设备的高效性。</p><h3 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h3><p>Hypervisor 也成为 VMM(virtual machine monitor) 虚拟机管理程序，负责与不同虚拟机之间打交道。<br>在没有虚拟化硬件扩展的情况下 guest OS 和 guest application 都需要在 非特权 de-privileged 模式下运行，此时 Hypervisor 跑在特权模式下，负责管理硬件资源，与 VM 互动。</p><h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>Popek 和 Goldberg 有一篇虚拟化的经典论文，把需要在特权模式下执行的指令分成了两类：</p><ul><li><strong>sensitive instructions 敏感指令</strong>：操作特权资源的指令，包括修改虚拟机的运行模式或者下面物理机的状态；读写时钟、中断等寄存器；访问存储保护系统、地址重定位系统及所有的I&#x2F;O指令。</li><li><strong>privileged instructions 特权指令</strong>：系统中有一些操作和管理关键系统资源的指令，这些指令只有在最高特权级上能够正确运行。如果在非最高特权级上运行，特权指令会引发一个异常，处理器会陷入到最高特权级，交由系统软件处理了。</li></ul><p>其中，敏感指令是特权指令的子集。这种标准被称为 classically virtualized 经典可虚拟化模型。</p><h3 id="特权接触和陷入模拟"><a href="#特权接触和陷入模拟" class="headerlink" title="特权接触和陷入模拟"></a>特权接触和陷入模拟</h3><p>虚拟化场景下，要求 GuestOS 内核的特权解除。当其需要执行特权指令时，会产生 trap，被 VMM 捕获并由 VMM 完成。这就是 **特权解除和陷入模拟(Privilege deprivileging&#x2F;Trap-and-Emulation)**。</p><blockquote><p> 对于一般 RISC 处理器，如 MIPS，PowerPC 以及SPARC，敏感指令肯定是特权指令，但是x86 例外，x86绝大多数的敏感指令是特权指令，但是由于部分敏感指令不是特权指令，执行这些指令的时候不会自动trap被VMM捕获。</p></blockquote><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><h4 id="完全虚拟化-Pure-virtualization"><a href="#完全虚拟化-Pure-virtualization" class="headerlink" title="完全虚拟化 Pure virtualization"></a>完全虚拟化 Pure virtualization</h4><p>完全虚拟化要求硬件架构是可虚拟化的，当 捕获(trap) 进入 hypervisor 后，由 hypervisor 去模拟敏感指令的执行，这项技术也被称为陷入模式(trap-and-emulate)。当一个 guest OS 想要去访问特权资源（物理外设），就会产生一个 trap 唤醒 hypervisor，hypervisor 去模拟这个访问，然后返回到 guest OS 的下一条指令去继续执行。</p><p>其采用了<strong>优先级压缩技术 Ring Compression</strong> 和 <strong>二进制代码翻译技术 Binary Translation</strong><br>优先级压缩技术使得 VMM 和 Guest 分别运行在不同特权级下。 对x86架构而言，即VMM运行在最高特权级别Ring 0下，Guest OS运行在Ring 1下，用户应用运行在Ring 3下。因此，Guest OS的核心指令无法直接下达到计算机系统硬件执行，而是需要经过VMM的捕获和模拟执行（部分难以虚拟化的指令需要通过二进制翻译技术进行转换）。</p><h4 id="半虚拟化-para-virtualization"><a href="#半虚拟化-para-virtualization" class="headerlink" title="半虚拟化 para-virtualization"></a>半虚拟化 para-virtualization</h4><p>半虚拟化通过修改 guest OS 的源码，使其避免难以虚拟化的指令（虚拟化漏洞）。操作系统通常会使用到处理器提供的全部功能，例如特权级别、地址空间和控制寄存器等。类虚拟化首先要解决的问题就是如何陷入VMM。典型的做法是修改 guest OS 的相关代码，让 os主动让出特权级别，而运行在次一级特权上。而当 guest OS 需要执行特权指令时，触发保护机制并通过 VMM 模拟。</p><p>半虚拟化通常能够达到比全虚拟化更好的性能，但是需要修改 OS 源码，而非运行时译码和处理。</p><blockquote><p>其与 partial-virtualization 有些差异，这只虚拟化部分外设来满足某些专门的软件的执行环境，但是不能运行所有可能运行在物理机上的软件。</p></blockquote><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><p>从虚拟化概念的提出，虚拟化技术经过了三个阶段的进化。</p><p><strong>第一个阶段</strong>，所有的虚拟管理程序(hypervisor)在内核态实现，实现对稀缺资源的多路复用。例如 IBM VM&#x2F;370。<br><strong>第二个阶段</strong>，主流的虚拟机管理程序将管理函数的实现迁移到用户态，通过系统调用在宿主操作系统上做文章。然而，一些功能仍然需要到内核态进行，比如指令模拟和虚拟内存。<br><strong>第三个阶段</strong>，一些厂商开始从硬件层面支持虚拟化（Intel VMX 和 AMD SVM），进一步降低了虚拟化中内核操作的占比，将这一部分功能转由硬件代为实现，提高了性能。</p><p>现在很多基于硬件扩展的虚拟机管理程序分为两部分组成：**内核模式的模块(kernel-mode module)<strong>和</strong>用户模式的模块(user-mode helper)**。比如，经典的 Linux&#x2F;KVM-based 虚拟化系统就包含了一个 KVM 内核模块，同时对每个 VM 有一个用户态的 helper，比如 QEMU。其中，KVM 模块和硬件扩展和宿主内核打交道，用户模块则负责 VM 的管理和 IO 虚拟化。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虚拟化系统内核态的组件总是会有各种各样的问题，威胁到主机的安全。比如在 KVM 的发展中就有了上百个 CVE 漏洞报告。这些漏洞可能被利用从而进行 Denial of Service(DoS) 攻击。一旦 KVM 的内核模块被黑入了，那么其上运行的各个虚拟机都难逃其难。</p><blockquote><p>CVE（Common Vulnerabilities and Exposures）的全称是公共漏洞和暴露，是公开披露的网络安全漏洞列表。IT人员、安全研究人员查阅CVE获取漏洞的详细信息，进而根据漏洞评分确定漏洞解决的优先级。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;虚拟化是将单一物理设备模拟为相互隔离的多个虚拟设备，同时保证这些虚拟设备的高效性。&lt;/p&gt;
&lt;h3 id=&quot;Hypervisor&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Virtualization" scheme="http://bl-gs.github.io/categories/Virtualization/"/>
    
    
    <category term="Virtualization" scheme="http://bl-gs.github.io/tags/Virtualization/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://bl-gs.github.io/2023/08/09/2PL/"/>
    <id>http://bl-gs.github.io/2023/08/09/2PL/</id>
    <published>2023-08-09T14:21:47.561Z</published>
    <updated>2023-08-09T14:21:47.561Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://bl-gs.github.io/2023/08/09/MVCC/"/>
    <id>http://bl-gs.github.io/2023/08/09/MVCC/</id>
    <published>2023-08-09T14:21:42.730Z</published>
    <updated>2023-08-09T14:21:42.730Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>OCC And Its Derivation</title>
    <link href="http://bl-gs.github.io/2023/08/09/OCC/"/>
    <id>http://bl-gs.github.io/2023/08/09/OCC/</id>
    <published>2023-08-09T13:19:41.244Z</published>
    <updated>2023-08-13T13:59:51.612Z</updated>
    
    <content type="html"><![CDATA[<p>乐观并发控制协议(Optimistic Concurrent Control, OCC) 作为一种并发控制协议，在事务内存乃至数据库系统中都十分常见。在黑书《数据库系统概论》中描述为“基于验证的并发控制协议”。</p><h2 id="朴素-OCC-Conventional-OCC"><a href="#朴素-OCC-Conventional-OCC" class="headerlink" title="朴素 OCC (Conventional OCC)"></a>朴素 OCC (Conventional OCC)</h2><p>OCC 的基本思路是乐观地执行事务，然后在事务要提交地过程中验证操作的正确性并决定成功提交还是崩溃重试。它将事务的执行过程分为三个阶段：执行阶段、验证阶段、写入阶段。</p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>以读写操作为例。每个事务都有一个读集合和写集合：其中每次读操作会将其记录到读集合中，每次写操作会将其记录到写集合中。<br>所有的写操作需要将数据读出到写集合中，然后在私有的副本上做修改。其之后的读写操作也会在该副本上进行。<br>这些过程<strong>理论上</strong>不需要上锁。（实际实现中可能需要上锁，为的是能够保证事务不会读到部分更新的数据，同时也能够提早发现冲突，但是也带来一定开销）</p><h3 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h3><p>事务需要对其操作进行验证，来确保事务执行的一致性。黑书中的介绍是对比多个并发事务的读写集合，确保没有发生 <strong>读-写冲突</strong> 或者 <strong>写-写冲突</strong>。此时，需要对事务读写集合的有效生命周期进行规定，即从其开始验证到没有比它更早开始的事务。但是从实现角度上看，这个实现起来未免引入非常大的同步开销。</p><p>一个改进是为数据项附加时间戳。有一个单调递增的全局时间戳，每次事务开始时会将其原子加一，获得当前事务的起始时间戳 <code>sts</code>；在开始验证时将其原子加一，并获得当前事务的提交时间戳 <code>cts</code>。<br>根据这个时间戳，事务读写集合的有效生命周期能够确定到当前系统中不存在事务有小于当前事务 <code>cts</code> 的 <code>sts</code>。此时无需再验证其读写集合。</p><p>但是这个同步开销依然不少。因此，人们直接将线程同步的工作交给时间戳来完成。在执行时，将对应数据项的时间戳读入读写集合。在验证的过程中，确保该时间戳仍未改变，表示数据也未被改变。此时验证通过。相反，如果时间戳改变了，则标明数据已经被修改。（原因是事务需要在写入阶段顺带用 <code>cts</code> 更新时间戳）</p><h3 id="写入阶段"><a href="#写入阶段" class="headerlink" title="写入阶段"></a>写入阶段</h3><p>在这一阶段中，事务将所有数据写入持久性存储器。同时用 <code>cts</code> 更新数据项的时间戳。事务执行完毕。</p><h3 id="其他讨论"><a href="#其他讨论" class="headerlink" title="其他讨论"></a>其他讨论</h3><p>某种意义上讲，只读事务可以不需要验证阶段和写入阶段。同时，验证阶段和写入阶段都需要保持互斥；也就是说，我在一个数据项的时间戳验证、数据更新和时间戳更新，这一堆操作需要“原子”地完成。</p><p>除此之外，还有说在读集合验证结束后就能够直接释放其对应地锁。不过我觉得，应该先对写集合元素上锁，然后对读集合上锁、验证，此时才能够释放读集合中元素的锁。这里还涉及死锁问题，大部分事务内存系统对写集合进行排序再上锁；保证读集合中不存在与写集合相同数据对象，每次验证读集合中一个对象，先上锁，验证时间戳，解锁。</p><p>当然，这只是最基本的 OCC 实现。还有很多变种。比如为了保证<strong>崩溃一致性</strong>，我们可以采用 WAL 的机制，在刚进入写入阶段、未更新原有数据时，先写入 redo 或者 undo 日志并将其持久化，然后再写入数据和更新时间戳。</p><h2 id="Silo"><a href="#Silo" class="headerlink" title="Silo"></a>Silo</h2><p>在论文 <em>Speedy Transaction in Multicore In-Memory Database</em> 中提出了一种名为 Silo 的并发控制协议（准确来说，这是一种内存数据库，不过这里只讨论它的并发控制策略）。它的目的是为了尽可能避免中心化操作的瓶颈，使用了 epoch-based<br> 的组提交策略。</p><h2 id="TicToc"><a href="#TicToc" class="headerlink" title="TicToc"></a>TicToc</h2><p>在论文 <em>TicToc: Time Traveling Optimistic Concurrency Control</em> 中提出了一种名为 TicToc 的并发控制协议。它考虑到全局分配时间戳的瓶颈，细粒度地管理各个数据项的时间戳更新。</p><h3 id="去中心化时间戳管理"><a href="#去中心化时间戳管理" class="headerlink" title="去中心化时间戳管理"></a>去中心化时间戳管理</h3><p>考虑一系列操作：</p><ul><li>A read(x)</li><li>B write(x)</li><li>B commits</li><li>A write(y)</li></ul><p>这个操作顺序是符合可串行化 Serializable 的定义的($A \rightarrow B$)，但是根据传统 OCC 的做法，A 在进入验证时因为 x 的时间戳已经被修改，从而验证失败并且崩溃。</p><p>所以 TicToc 做的就是在验证阶段生成时间戳，然后在写入阶段用该时间戳更新所有数据项。其中时间戳的生成规则如下<br>$$<br>    \exist commit_{ts}, \<br>    (\forall v \in {versions read by T}, v.wts \le commit_ts \le v.rts) \<br>    \wedge (\forall v \in {versions written by T}, v.rts &lt; commit_ts)<br>$$<br>这样所有已经提交的读事务都被排在写事务之前，所有已经提交的写事务都被排在读事务之前。</p><h3 id="事务流程"><a href="#事务流程" class="headerlink" title="事务流程"></a>事务流程</h3><p><strong>读阶段</strong>。事务将数据、wts、rts载入读&#x2F;写集合。</p><p><strong>验证阶段</strong>。开始时，需要将所有写集合元素上锁。然后计算 <code>cts</code>。计算如下：</p><pre><code>commit_ts = 0for e in WriteSet do    // e.tuple.rts means we need to read the latest timestamp of this data tuple.    commit_ts = max(commit_ts, e.tuple.rts + 1) endfor e in ReadSet do    commit_ts = max(commit_ts, e.commit_ts, e.wts)end</code></pre><p>接着需要检测是否发生冲突</p><pre><code>for r in ReadSet do     if r.rts &lt; commit_ts then        # Begin atomic section        if r.wts != r.tuple.wts or (r.tuple.rts &lt;= commit_ts and isLocked(r.tuple) and r.tuple not in WriteSet) then        abort()    else        r.tuple.rts = max(commit_ts, r.tuple.rts)    end    # End atomic sectionend</code></pre><p><strong>写入阶段</strong>。用计算得到的 <code>cts</code> 去更新所有数据项的时间戳。读集合的元素只需要更新读时间戳；写集合的元素需要同时更新两个时间戳。当然还有更新所有数据。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Tu, Stephen, Wenting Zheng, Eddie Kohler, Barbara Liskov, and Samuel Madden. “Speedy Transactions in Multicore In-Memory Databases.” In Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles, 18–32. Farminton Pennsylvania: ACM, 2013. <a href="https://doi.org/10.1145/2517349.2522713">https://doi.org/10.1145/2517349.2522713</a>.</p><p>[2] Yu, Xiangyao, Andrew Pavlo, Daniel Sanchez, and Srinivas Devadas. “TicToc: Time Traveling Optimistic Concurrency Control.” In Proceedings of the 2016 International Conference on Management of Data, 1629–42. San Francisco California USA: ACM, 2016. <a href="https://doi.org/10.1145/2882903.2882935">https://doi.org/10.1145/2882903.2882935</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;乐观并发控制协议(Optimistic Concurrent Control, OCC) 作为一种并发控制协议，在事务内存乃至数据库系统中都十分常见。在黑书《数据库系统概论》中描述为“基于验证的并发控制协议”。&lt;/p&gt;
&lt;h2 id=&quot;朴素-OCC-Conventional</summary>
      
    
    
    
    <category term="Transaction" scheme="http://bl-gs.github.io/categories/Transaction/"/>
    
    
    <category term="Transaction" scheme="http://bl-gs.github.io/tags/Transaction/"/>
    
    <category term="Concurrent Control" scheme="http://bl-gs.github.io/tags/Concurrent-Control/"/>
    
    <category term="OCC" scheme="http://bl-gs.github.io/tags/OCC/"/>
    
  </entry>
  
  <entry>
    <title>Transaction Introduction</title>
    <link href="http://bl-gs.github.io/2023/08/09/Transaction/"/>
    <id>http://bl-gs.github.io/2023/08/09/Transaction/</id>
    <published>2023-08-09T13:19:21.095Z</published>
    <updated>2023-08-09T14:18:00.555Z</updated>
    
    <content type="html"><![CDATA[<p><strong>事务</strong> 是访问并可能更新各种数据项的一个程序执行单元。简单的说，一个事务是这么一种操作，要么能够完成，要么不引起任何影响。也就是遵从 all-or-nothing 原语。</p><h2 id="事务的属性-Property"><a href="#事务的属性-Property" class="headerlink" title="事务的属性 Property"></a>事务的属性 Property</h2><ul><li><strong>原子性 Atomicity</strong>：事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映</li><li><strong>一致性 Consistency</strong>：以隔离的方式执行事务以保持事务的一致性</li><li><strong>隔离性 Isolative</strong>：尽管多个事务可能并发执行，但是需要保证，对于每个事务，其运行时不需关心其他事务的运行情况。确保隔离性是数据库系统中 <em>并发控制</em> 的责任。</li><li><strong>持久性 Durability</strong>：当一个事务完成之后，它对数据库的改变是永久的，即使出现系统故障也是如此。</li></ul><h2 id="事务的隔离等级-Isolation-Level"><a href="#事务的隔离等级-Isolation-Level" class="headerlink" title="事务的隔离等级 Isolation Level"></a>事务的隔离等级 Isolation Level</h2><p>在事务执行过程中，可能出现多种违背事务属性的情况：</p><ul><li><strong>不可重复读 Unrepeated read</strong>：一个事务中的多次重复的读操作返回的数据不同</li><li><strong>脏读 Dirty read</strong>：事务执行过程中读取到未提交事务或者中止事务的更新数据</li><li><strong>脏写 Dirty write</strong>：事务执行过程中将要写入的数据已经被未提交事务或者中止事务更新过</li><li><strong>幻读 Magic read</strong>：读到已提交插入的数据，幻读与不可重复读类似，幻读是查询到了另一个事务已提交的新插入数据，而不可重复读是查询到了另一个事务已提交更新的数据。</li></ul><p>根据 MySQL 规定的隔离等级，有如下：</p><ul><li><strong>可串行化 Serializable</strong>：通常保证可串行化的执行。但是一些数据库系统某些情况下允许非可串行化执行的方式来实现这种隔离级别</li><li><strong>可重复读 Repeatable read</strong>：只允许读取已提交的数据，并进一步要求在一个事务两次读取一个数据项期间，其他事务不得更新该数据项</li><li><strong>已提交读 Read commited</strong>：只允许读取已提交的数据，当不要求可重复读</li><li><strong>未提交读 Read uncommited</strong>：允许读取未提交数据</li></ul><p>其中，未提交读会导致脏读、不可重复读和幻读；已提交读会导致不可重复读和幻读；可重复读会导致幻读。<br>这几种隔离等级下，事务均不允许发生脏写。</p><h2 id="崩溃一致性-Crash-Consistency"><a href="#崩溃一致性-Crash-Consistency" class="headerlink" title="崩溃一致性 Crash Consistency"></a>崩溃一致性 Crash Consistency</h2><p>事务也需要满足崩溃一致性。当系统由于断电或者种种不可预知的原因崩溃时，已提交事务的影响需要保持持久化或者在重启后能够被恢复；同时，未提交事务和崩溃事务的影响在系统重启后需要被消除。</p>]]></content>
    
    
    <summary type="html">Transaction should be executed atomically. On the other hand, the effect of aborted transaction should be eliminated. In other words, the execution of a transaction should follow &quot;all-or-nothing&quot; semantics.</summary>
    
    
    
    <category term="Transaction" scheme="http://bl-gs.github.io/categories/Transaction/"/>
    
    
    <category term="Transaction" scheme="http://bl-gs.github.io/tags/Transaction/"/>
    
  </entry>
  
</feed>
