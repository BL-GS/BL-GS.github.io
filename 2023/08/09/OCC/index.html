<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>OCC And Its Derivation</title><meta name="description" content="This man is too lazy to introduce himself"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="乐观并发控制协议(Optimistic Concurrent Control, OCC) 作为一种并发控制协议，在事务内存乃至数据库系统中都十分常见。在黑书《数据库系统概论》中描述为“基于验证的并发控制协议”。
朴素 OCC (Conventional OCC)OCC 的基本思路是乐观地执行事务，然后在事务要提交地过程中验证操作的正确性并决定成功提交还是崩溃重试。它将事务的执行过程分为三个阶段：执行阶段、验证阶段、写入阶段。
执行阶段以读写操作为例。每个事务都有一个读集合和写集合：其中每次读操作会将其记录到读集合中，每次写操作会将其记录到写集合中。所有的写操作需要将数据读出到写集合中，然后在私有的副本上做修改。其之后的读写操作也会在该副本上进行。这些过程理论上不需要上锁。（实际实现中可能需要上锁，为的是能够.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Xinrui Zheng's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">OCC And Its Derivation</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0-OCC-Conventional-OCC"><span class="toc-text">朴素 OCC (Conventional OCC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="toc-text">执行阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5"><span class="toc-text">验证阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E9%98%B6%E6%AE%B5"><span class="toc-text">写入阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AE%A8%E8%AE%BA"><span class="toc-text">其他讨论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Silo"><span class="toc-text">Silo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TicToc"><span class="toc-text">TicToc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E6%97%B6%E9%97%B4%E6%88%B3%E7%AE%A1%E7%90%86"><span class="toc-text">去中心化时间戳管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">事务流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Transaction"><i class="tag post-item-tag">Transaction</i></a><a href="/tags/Concurrent%20Control"><i class="tag post-item-tag">Concurrent Control</i></a><a href="/tags/OCC"><i class="tag post-item-tag">OCC</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">OCC And Its Derivation</h1><time class="has-text-grey" datetime="2023-08-09T13:19:41.244Z">2023-08-09</time><article class="mt-2 post-content"><p>乐观并发控制协议(Optimistic Concurrent Control, OCC) 作为一种并发控制协议，在事务内存乃至数据库系统中都十分常见。在黑书《数据库系统概论》中描述为“基于验证的并发控制协议”。</p>
<h2 id="朴素-OCC-Conventional-OCC"><a href="#朴素-OCC-Conventional-OCC" class="headerlink" title="朴素 OCC (Conventional OCC)"></a>朴素 OCC (Conventional OCC)</h2><p>OCC 的基本思路是乐观地执行事务，然后在事务要提交地过程中验证操作的正确性并决定成功提交还是崩溃重试。它将事务的执行过程分为三个阶段：执行阶段、验证阶段、写入阶段。</p>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>以读写操作为例。每个事务都有一个读集合和写集合：其中每次读操作会将其记录到读集合中，每次写操作会将其记录到写集合中。<br>所有的写操作需要将数据读出到写集合中，然后在私有的副本上做修改。其之后的读写操作也会在该副本上进行。<br>这些过程<strong>理论上</strong>不需要上锁。（实际实现中可能需要上锁，为的是能够保证事务不会读到部分更新的数据，同时也能够提早发现冲突，但是也带来一定开销）</p>
<h3 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h3><p>事务需要对其操作进行验证，来确保事务执行的一致性。黑书中的介绍是对比多个并发事务的读写集合，确保没有发生 <strong>读-写冲突</strong> 或者 <strong>写-写冲突</strong>。此时，需要对事务读写集合的有效生命周期进行规定，即从其开始验证到没有比它更早开始的事务。但是从实现角度上看，这个实现起来未免引入非常大的同步开销。</p>
<p>一个改进是为数据项附加时间戳。有一个单调递增的全局时间戳，每次事务开始时会将其原子加一，获得当前事务的起始时间戳 <code>sts</code>；在开始验证时将其原子加一，并获得当前事务的提交时间戳 <code>cts</code>。<br>根据这个时间戳，事务读写集合的有效生命周期能够确定到当前系统中不存在事务有小于当前事务 <code>cts</code> 的 <code>sts</code>。此时无需再验证其读写集合。</p>
<p>但是这个同步开销依然不少。因此，人们直接将线程同步的工作交给时间戳来完成。在执行时，将对应数据项的时间戳读入读写集合。在验证的过程中，确保该时间戳仍未改变，表示数据也未被改变。此时验证通过。相反，如果时间戳改变了，则标明数据已经被修改。（原因是事务需要在写入阶段顺带用 <code>cts</code> 更新时间戳）</p>
<h3 id="写入阶段"><a href="#写入阶段" class="headerlink" title="写入阶段"></a>写入阶段</h3><p>在这一阶段中，事务将所有数据写入持久性存储器。同时用 <code>cts</code> 更新数据项的时间戳。事务执行完毕。</p>
<h3 id="其他讨论"><a href="#其他讨论" class="headerlink" title="其他讨论"></a>其他讨论</h3><p>某种意义上讲，只读事务可以不需要验证阶段和写入阶段。同时，验证阶段和写入阶段都需要保持互斥；也就是说，我在一个数据项的时间戳验证、数据更新和时间戳更新，这一堆操作需要“原子”地完成。</p>
<p>除此之外，还有说在读集合验证结束后就能够直接释放其对应地锁。不过我觉得，应该先对写集合元素上锁，然后对读集合上锁、验证，此时才能够释放读集合中元素的锁。这里还涉及死锁问题，大部分事务内存系统对写集合进行排序再上锁；保证读集合中不存在与写集合相同数据对象，每次验证读集合中一个对象，先上锁，验证时间戳，解锁。</p>
<p>当然，这只是最基本的 OCC 实现。还有很多变种。比如为了保证<strong>崩溃一致性</strong>，我们可以采用 WAL 的机制，在刚进入写入阶段、未更新原有数据时，先写入 redo 或者 undo 日志并将其持久化，然后再写入数据和更新时间戳。</p>
<h2 id="Silo"><a href="#Silo" class="headerlink" title="Silo"></a>Silo</h2><p>在论文 <em>Speedy Transaction in Multicore In-Memory Database</em> 中提出了一种名为 Silo 的并发控制协议（准确来说，这是一种内存数据库，不过这里只讨论它的并发控制策略）。它的目的是为了尽可能避免中心化操作的瓶颈，使用了 epoch-based<br> 的组提交策略。</p>
<h2 id="TicToc"><a href="#TicToc" class="headerlink" title="TicToc"></a>TicToc</h2><p>在论文 <em>TicToc: Time Traveling Optimistic Concurrency Control</em> 中提出了一种名为 TicToc 的并发控制协议。它考虑到全局分配时间戳的瓶颈，细粒度地管理各个数据项的时间戳更新。</p>
<h3 id="去中心化时间戳管理"><a href="#去中心化时间戳管理" class="headerlink" title="去中心化时间戳管理"></a>去中心化时间戳管理</h3><p>考虑一系列操作：</p>
<ul>
<li>A read(x)</li>
<li>B write(x)</li>
<li>B commits</li>
<li>A write(y)</li>
</ul>
<p>这个操作顺序是符合可串行化 Serializable 的定义的($A \rightarrow B$)，但是根据传统 OCC 的做法，A 在进入验证时因为 x 的时间戳已经被修改，从而验证失败并且崩溃。</p>
<p>所以 TicToc 做的就是在验证阶段生成时间戳，然后在写入阶段用该时间戳更新所有数据项。其中时间戳的生成规则如下<br>$$<br>    \exist commit_{ts}, \<br>    (\forall v \in {versions read by T}, v.wts \le commit_ts \le v.rts) \<br>    \wedge (\forall v \in {versions written by T}, v.rts &lt; commit_ts)<br>$$<br>这样所有已经提交的读事务都被排在写事务之前，所有已经提交的写事务都被排在读事务之前。</p>
<h3 id="事务流程"><a href="#事务流程" class="headerlink" title="事务流程"></a>事务流程</h3><p><strong>读阶段</strong>。事务将数据、wts、rts载入读&#x2F;写集合。</p>
<p><strong>验证阶段</strong>。开始时，需要将所有写集合元素上锁。然后计算 <code>cts</code>。计算如下：</p>
<pre><code>commit_ts = 0
for e in WriteSet do
    // e.tuple.rts means we need to read the latest timestamp of this data tuple.
    commit_ts = max(commit_ts, e.tuple.rts + 1) 
end
for e in ReadSet do
    commit_ts = max(commit_ts, e.commit_ts, e.wts)
end
</code></pre>
<p>接着需要检测是否发生冲突</p>
<pre><code>for r in ReadSet do 
    if r.rts &lt; commit_ts then
        # Begin atomic section
        if r.wts != r.tuple.wts or (r.tuple.rts &lt;= commit_ts and isLocked(r.tuple) and r.tuple not in WriteSet) then
        abort()
    else
        r.tuple.rts = max(commit_ts, r.tuple.rts)
    end
    # End atomic section
end
</code></pre>
<p><strong>写入阶段</strong>。用计算得到的 <code>cts</code> 去更新所有数据项的时间戳。读集合的元素只需要更新读时间戳；写集合的元素需要同时更新两个时间戳。当然还有更新所有数据。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Tu, Stephen, Wenting Zheng, Eddie Kohler, Barbara Liskov, and Samuel Madden. “Speedy Transactions in Multicore In-Memory Databases.” In Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles, 18–32. Farminton Pennsylvania: ACM, 2013. <a target="_blank" rel="noopener" href="https://doi.org/10.1145/2517349.2522713">https://doi.org/10.1145/2517349.2522713</a>.</p>
<p>[2] Yu, Xiangyao, Andrew Pavlo, Daniel Sanchez, and Srinivas Devadas. “TicToc: Time Traveling Optimistic Concurrency Control.” In Proceedings of the 2016 International Conference on Management of Data, 1629–42. San Francisco California USA: ACM, 2016. <a target="_blank" rel="noopener" href="https://doi.org/10.1145/2882903.2882935">https://doi.org/10.1145/2882903.2882935</a>.</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/08/09/MVCC/" title=""><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: </span></a><a class="button is-default" href="/2023/08/09/Transaction/" title="Transaction Introduction"><span class="has-text-weight-semibold">Next: Transaction Introduction</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="BL-GS/BLGS.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/BL-GS"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/people/blgs"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Xinrui Zheng 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>