<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Usage of Verilator</title><meta name="description" content="This man is too lazy to introduce himself"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Verilator 是一款开源的 Verilog 仿真工具，可以将 Verilog 代码转化为 SystemC 或 C++ 代码，继而编译成可执行文件，从而实现 Verilog 代码的仿真。
工作流程
使用 Chisel 作为 RTL 语言开发硬件
Chisel 编译生成 Verilog 文件
Verilator 将 Verilog 文件转化成 SystemC 或者 C++ 代码文件
使用 C&amp;#x2F;C++ 编写测试的激励文件，调用指定接口与 Verilog 代码进行互动 
C&amp;#x2F;C++ 的 Wrapper 与 Verilator 的输出一起编译生成完整的仿真程序

Verilator 仿真的粒度是一个完整的时钟周期，且确定各个组合逻辑达到稳定状态，也就是忽略了组合逻辑的延迟问题，这个只有在电路.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Xinrui Zheng's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Usage of Verilator</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Verilator-%E7%BC%96%E8%AF%91-Verilog-%E6%96%87%E4%BB%B6"><span class="toc-text">Verilator 编译 Verilog 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Verilator"><span class="toc-text">安装 Verilator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91-Verilog-%E7%94%9F%E6%88%90-C-%E4%BB%A3%E7%A0%81"><span class="toc-text">编译 Verilog 生成 C++ 代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%92%8C-Verilog-%E4%BA%92%E5%8A%A8"><span class="toc-text">C++ 和 Verilog 互动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E9%A1%B6%E5%B1%82%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BF%A1%E5%8F%B7"><span class="toc-text">直接访问顶层输入输出信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Simple-Example"><span class="toc-text">Simple Example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="toc-text">事件驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%A4%8D%E5%88%B6"><span class="toc-text">实例复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DPI-C"><span class="toc-text">DPI-C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DPI-System-Task-Functions"><span class="toc-text">DPI System Task&#x2F;Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scope"><span class="toc-text">Scope</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Tool"><i class="tag post-item-tag">Tool</i></a><a href="/tags/Hardware"><i class="tag post-item-tag">Hardware</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Usage of Verilator</h1><time class="has-text-grey" datetime="2023-09-20T13:17:32.851Z">2023-09-20</time><article class="mt-2 post-content"><p>Verilator 是一款开源的 Verilog 仿真工具，可以将 Verilog 代码转化为 SystemC 或 C++ 代码，继而编译成可执行文件，从而实现 Verilog 代码的仿真。</p>
<h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><ol>
<li>使用 Chisel 作为 RTL 语言开发硬件</li>
<li>Chisel 编译生成 Verilog 文件</li>
<li>Verilator 将 Verilog 文件转化成 SystemC 或者 C++ 代码文件</li>
<li>使用 C&#x2F;C++ 编写测试的激励文件，调用指定接口与 Verilog 代码进行互动 </li>
<li>C&#x2F;C++ 的 Wrapper 与 Verilator 的输出一起编译生成完整的仿真程序</li>
</ol>
<p>Verilator 仿真的粒度是一个完整的时钟周期，且确定各个组合逻辑达到稳定状态，也就是忽略了组合逻辑的延迟问题，这个只有在电路综合的时候才能发现。</p>
<h1 id="Verilator-编译-Verilog-文件"><a href="#Verilator-编译-Verilog-文件" class="headerlink" title="Verilator 编译 Verilog 文件"></a>Verilator 编译 Verilog 文件</h1><h2 id="安装-Verilator"><a href="#安装-Verilator" class="headerlink" title="安装 Verilator"></a>安装 Verilator</h2><p>假如是使用源码编译而非使用发行版包管理器安装的，那么还需要设置环境变量</p>
<pre><code class="shell">export VERILATOR_ROOT=&lt;path-to-where-verilator-was-installed&gt;
export PATH=$VERILATOR_ROOT/bin:$PATH
</code></pre>
<h2 id="编译-Verilog-生成-C-代码"><a href="#编译-Verilog-生成-C-代码" class="headerlink" title="编译 Verilog 生成 C++ 代码"></a>编译 Verilog 生成 C++ 代码</h2><p>命令如下：</p>
<pre><code class="shell">verilator &lt;options&gt; &lt;verilog-file&gt; &lt;cpp-file&gt;
</code></pre>
<p>其中 <code>verilog-file</code> 包括所有的 Verilog 文件，<code>cpp-file</code> 则指示生成的 Cpp 文件名。</p>
<p><code>option</code> 有：</p>
<ul>
<li><code>--cc</code> 获得 C++ 文件的输出</li>
<li><code>--exe</code> 带上 C++ 的测试激励文件，构建结果是一个可执行文件</li>
<li><code>--build</code> 直接编译生成目标文件</li>
<li><code>-j &lt;num&gt;</code> 会使用 num 个 CPU 进行编译</li>
<li><code>-Wall</code> Verilator 会生成尽可能多的警告信息</li>
<li><code>--trace</code> 导出波形文件</li>
<li><code>--top-module</code> 指定 Verilog 的顶层模块</li>
<li><code>--Mdir</code> 指定生成文件的目录</li>
<li><code>-CFLAGS &lt;flag&gt;</code> 指定 GCC 的编译选项</li>
<li><code>-I &lt;include&gt;</code> 指定包含的路径</li>
</ul>
<p>生成的 C++ 代码会在 obj-dir 文件夹下，以及对应的可执行文件。</p>
<h1 id="C-和-Verilog-互动"><a href="#C-和-Verilog-互动" class="headerlink" title="C++ 和 Verilog 互动"></a>C++ 和 Verilog 互动</h1><p>Verilator 提供了两种使用 C&#x2F;C++ 访问 Verilog 信号的方法：直接访问顶层输入&#x2F;输出信号和 DPI-C 机制。</p>
<p>需要注意的是 Verilator 4.210 版本后，其接口做了一些改动。。。。</p>
<h2 id="直接访问顶层输入输出信号"><a href="#直接访问顶层输入输出信号" class="headerlink" title="直接访问顶层输入输出信号"></a>直接访问顶层输入输出信号</h2><p>Verilator 将 Verilog 中的顶层模块转化为一个 C++ 的类，其输入输出信号为共有的成员变量，那么我们能够直接访问这些信号，进行写入或者读取。参考代码 <a target="_blank" rel="noopener" href="https://github.com/verilator/verilator/blob/master/examples/make_tracing_c/sim_main.cpp">cpp_tracing</a></p>
<h3 id="Simple-Example"><a href="#Simple-Example" class="headerlink" title="Simple Example"></a>Simple Example</h3><p>其中，我们对顶层模块设置其输入，调用 <code>contextp-&gt;timeInc</code> 函数推进时间轴，然后调用顶层模块的 <code>eval</code> 成员函数模拟硬件行为；在仿真结束后调用顶层模块的 <code>final</code> 成员函数清理现场。</p>
<p>当有多个仿真实例时，模拟时则对每个模块依次调用 <code>eval_step</code> 成员函数，然后依次调用 <code>eval_end_step</code> 成员函数。本质上 <code>eval</code> 函数是对上述两个函数的打包。</p>
<p>需要注意的是，组合逻辑并不会在时序逻辑之前计算，因此，在推进时钟信号时，最好用单独的 <code>eval</code> 调用来完成所有非时钟输入。（也就是单独划出一个模拟阶段，用来完成时序逻辑之前的组合逻辑，之后再推进时钟信号）</p>
<h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>在添加 <code>--timing</code> 编译选项时，还有两个额外的函数用于检测是否有被悬置的事件：</p>
<ul>
<li><code>eventsPending</code> 成员函数，当有被延迟的时间时返回 true</li>
<li><code>nextTimeSlot</code> 成员函数，返回下一个被延迟事件的模拟时间，仅能 在<code>eventsPending</code> 返回 true 时被调用</li>
</ul>
<p>调用 <code>eventPending</code> 来检查是否能够继续仿真，然后调用 <code>nextTimeSlot</code> 来推进时间</p>
<p>一般情况下，调用 <code>eval</code> 或者 <code>eval_step</code> 时，Verilator 查找所有时钟信号，模拟其对应的逻辑块；但是当加上 <code>--time</code> 编译选项后，它会将延迟所有进程，等待模拟时间推进。</p>
<h3 id="实例复制"><a href="#实例复制" class="headerlink" title="实例复制"></a>实例复制</h3><p>通过 Verilator 的接口 <code>prepareClone</code> 和 <code>atClone</code> 函数手动重建模型，从而在另一个线程中使用。如：</p>
<pre><code class="c++">// static function pointers to fit pthread_atfork
static auto prepareClone = []()&#123; topp-&gt;prepareClone(); &#125;;
static auto atClone = []()&#123; topp-&gt;atClone(); &#125;;

// in main function, register the handlers:
pthread_atfork(prepareClone, atClone, atClone);
</code></pre>
<h2 id="DPI-C"><a href="#DPI-C" class="headerlink" title="DPI-C"></a>DPI-C</h2><p>在 Verilog 源码中添加：</p>
<pre><code class="verilog">import &quot;DPI-C&quot; function int add (input int a, input int b);

initial begin
   $display(&quot;%x + %x = %x&quot;, 1, 2, add(1,2));
endtask
</code></pre>
<p>在在编译后，Verilator 会生成 <code>Vour__Dpi.h</code> 以及该函数的声明：</p>
<pre><code class="c++">extern int add(int a, int b);
</code></pre>
<p>在 C++ 代码中对函数做实现：</p>
<pre><code class="c++">#include &quot;svdpi.h&quot;
#include &quot;Vour__Dpi.h&quot;
int add(int a, int b) &#123; return a+b; &#125;
</code></pre>
<p>即可在 Verilog 里调用到该 C++ 函数。</p>
<h3 id="DPI-System-Task-Functions"><a href="#DPI-System-Task-Functions" class="headerlink" title="DPI System Task&#x2F;Functions"></a>DPI System Task&#x2F;Functions</h3><p>在 Verilog 中导出一个任务：</p>
<pre><code class="verilog">export &quot;DPI-C&quot; task publicSetBool;

task publicSetBool;
   input bit in_bool;
   var_bool = in_bool;
endtask
</code></pre>
<p>之后 Verilator 会生成相应的函数声明：</p>
<pre><code class="c++">extern void publicSetBool(svBit in_bool);
</code></pre>
<p>即可在 C++ 中调用该函数：</p>
<pre><code class="c++">#include &quot;Vour__Dpi.h&quot;
publicSetBool(value);
Vour::publicSetBool(value);
top-&gt;publicSetBool(value);
</code></pre>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>由于 DPI Task 能够访问任意寄存器或者线网，因此他需要设置一个 scope。通过 <code>svdpi.h</code> 里的接口。在模块初始化后、任务或者函数开始前设置：</p>
<pre><code class="c++">#include &quot;svdpi.h&quot;
...
const svScope scope = svGetScopeFromName(&quot;TOP.dut&quot;);
assert(scope);  // Check for nullptr if scope not found
svSetScope(scope);
</code></pre>
<p>这里，顶层模块名称为 <code>dut</code>，Verilator 会加一个 Top 前缀</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a target="_blank" rel="noopener" href="https://soc.ustc.edu.cn/CECS/lab2/verilator/">https://soc.ustc.edu.cn/CECS/lab2/verilator/</a></li>
<li><a target="_blank" rel="noopener" href="https://verilator.org/guide/latest/">https://verilator.org/guide/latest/</a></li>
</ol>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/09/19/XiangSahnHExtException/" title="Exception of XiangShan H-Extension"><span class="has-text-weight-semibold">Next: Exception of XiangShan H-Extension</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="BL-GS/BLGS.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/BL-GS"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/people/blgs"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Xinrui Zheng 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>